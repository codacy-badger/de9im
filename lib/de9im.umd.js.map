{"version":3,"file":"de9im.umd.js","sources":["../node_modules/earcut/src/earcut.js","../src/util/triangulate.js","../src/util/clipper.js","../src/util/helpers.js","../src/util/invariant.js","../src/util/meta.js","../node_modules/geojson-rbush/quickselect.js","../node_modules/geojson-rbush/rbush.js","../node_modules/geojson-rbush/index.js","../node_modules/@turf/meta/main.es.js","../src/util/partition.js","../src/util/point.js","../src/util/line.js","../src/util/polygon.js","../src/util/index.js","../src/within/line.js","../src/within/point.js","../src/within/polygon.js","../src/within/index.js","../src/contains/index.js","../src/coveredby/line.js","../src/coveredby/point.js","../src/coveredby/polygon.js","../src/coveredby/index.js","../src/crosses/point.js","../src/crosses/line.js","../src/crosses/polygon.js","../src/intersects/point.js","../src/intersects/line.js","../src/intersects/polygon.js","../src/intersects/index.js","../src/overlaps/line.js","../src/overlaps/point.js","../src/overlaps/polygon.js","../src/touches/point.js","../src/touches/line.js","../src/touches/polygon.js","../src/touches/index.js","../src/covers/index.js","../src/crosses/index.js","../src/disjoint/index.js","../src/equals/index.js","../src/overlaps/index.js"],"sourcesContent":["'use strict';\n\nmodule.exports = earcut;\nmodule.exports.default = earcut;\n\nfunction earcut(data, holeIndices, dim) {\n\n    dim = dim || 2;\n\n    var hasHoles = holeIndices && holeIndices.length,\n        outerLen = hasHoles ? holeIndices[0] * dim : data.length,\n        outerNode = linkedList(data, 0, outerLen, dim, true),\n        triangles = [];\n\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n    var minX, minY, maxX, maxY, x, y, invSize;\n\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = maxX = data[0];\n        minY = maxY = data[1];\n\n        for (var i = dim; i < outerLen; i += dim) {\n            x = data[i];\n            y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 1 / invSize : 0;\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);\n\n    return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    var i, last;\n\n    if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n    } else {\n        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n    }\n\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n\n    return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n\n    var p = start,\n        again;\n    do {\n        again = false;\n\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n\n        } else {\n            p = p.next;\n        }\n    } while (again || p !== end);\n\n    return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n    var stop = ear,\n        prev, next;\n\n    // iterate through ears, slicing them one by one\n    while (ear.prev !== ear.next) {\n        prev = ear.prev;\n        next = ear.next;\n\n        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n            // cut off the triangle\n            triangles.push(prev.i / dim);\n            triangles.push(ear.i / dim);\n            triangles.push(next.i / dim);\n\n            removeNode(ear);\n\n            // skipping the next vertex leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n\n            continue;\n        }\n\n        ear = next;\n\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n            // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(ear, triangles, dim);\n                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            }\n\n            break;\n        }\n    }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    var p = ear.next.next;\n\n    while (p !== ear.prev) {\n        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n\n    return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // triangle bbox; min & max are calculated like this for speed\n    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),\n        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),\n        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),\n        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);\n\n    // z-order range for the current triangle bbox;\n    var minZ = zOrder(minTX, minTY, minX, minY, invSize),\n        maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);\n\n    var p = ear.prevZ,\n        n = ear.nextZ;\n\n    // look for points inside the triangle in both directions\n    while (p && p.z >= minZ && n && n.z <= maxZ) {\n        if (p !== ear.prev && p !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n\n        if (n !== ear.prev && n !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&\n            area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    // look for remaining points in decreasing z-order\n    while (p && p.z >= minZ) {\n        if (p !== ear.prev && p !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n\n    // look for remaining points in increasing z-order\n    while (n && n.z <= maxZ) {\n        if (n !== ear.prev && n !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&\n            area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n    var p = start;\n    do {\n        var a = p.prev,\n            b = p.next.next;\n\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n            triangles.push(a.i / dim);\n            triangles.push(p.i / dim);\n            triangles.push(b.i / dim);\n\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n\n            p = start = b;\n        }\n        p = p.next;\n    } while (p !== start);\n\n    return p;\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    var a = start;\n    do {\n        var b = a.next.next;\n        while (b !== a.prev) {\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                var c = splitPolygon(a, b);\n\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, invSize);\n                earcutLinked(c, triangles, dim, minX, minY, invSize);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    var queue = [],\n        i, len, start, end, list;\n\n    for (i = 0, len = holeIndices.length; i < len; i++) {\n        start = holeIndices[i] * dim;\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n\n    queue.sort(compareX);\n\n    // process holes from left to right\n    for (i = 0; i < queue.length; i++) {\n        eliminateHole(queue[i], outerNode);\n        outerNode = filterPoints(outerNode, outerNode.next);\n    }\n\n    return outerNode;\n}\n\nfunction compareX(a, b) {\n    return a.x - b.x;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n    outerNode = findHoleBridge(hole, outerNode);\n    if (outerNode) {\n        var b = splitPolygon(outerNode, hole);\n        filterPoints(b, b.next);\n    }\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    var p = outerNode,\n        hx = hole.x,\n        hy = hole.y,\n        qx = -Infinity,\n        m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                if (x === hx) {\n                    if (hy === p.y) return p;\n                    if (hy === p.next.y) return p.next;\n                }\n                m = p.x < p.next.x ? p : p.next;\n            }\n        }\n        p = p.next;\n    } while (p !== outerNode);\n\n    if (!m) return null;\n\n    if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    var stop = m,\n        mx = m.x,\n        my = m.y,\n        tanMin = Infinity,\n        tan;\n\n    p = m.next;\n\n    while (p !== stop) {\n        if (hx >= p.x && p.x >= mx && hx !== p.x &&\n                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n            if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n\n        p = p.next;\n    }\n\n    return m;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n    var p = start;\n    do {\n        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    } while (p !== start);\n\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n\n    sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    var i, p, q, e, tail, numMerges, pSize, qSize,\n        inSize = 1;\n\n    do {\n        p = list;\n        list = null;\n        tail = null;\n        numMerges = 0;\n\n        while (p) {\n            numMerges++;\n            q = p;\n            pSize = 0;\n            for (i = 0; i < inSize; i++) {\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            qSize = inSize;\n\n            while (pSize > 0 || (qSize > 0 && q)) {\n\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n\n                if (tail) tail.nextZ = e;\n                else list = e;\n\n                e.prevZ = tail;\n                tail = e;\n            }\n\n            p = q;\n        }\n\n        tail.nextZ = null;\n        inSize *= 2;\n\n    } while (numMerges > 1);\n\n    return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = 32767 * (x - minX) * invSize;\n    y = 32767 * (y - minY) * invSize;\n\n    x = (x | (x << 8)) & 0x00FF00FF;\n    x = (x | (x << 4)) & 0x0F0F0F0F;\n    x = (x | (x << 2)) & 0x33333333;\n    x = (x | (x << 1)) & 0x55555555;\n\n    y = (y | (y << 8)) & 0x00FF00FF;\n    y = (y | (y << 4)) & 0x0F0F0F0F;\n    y = (y | (y << 2)) & 0x33333333;\n    y = (y | (y << 1)) & 0x55555555;\n\n    return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    var p = start,\n        leftmost = start;\n    do {\n        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;\n        p = p.next;\n    } while (p !== start);\n\n    return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&\n           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&\n           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&\n           locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    if ((equals(p1, q1) && equals(p2, q2)) ||\n        (equals(p1, q2) && equals(p2, q1))) return true;\n    return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&\n           area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    var p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n                intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    } while (p !== a);\n\n    return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ?\n        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    var p = a,\n        inside = false,\n        px = (a.x + b.x) / 2,\n        py = (a.y + b.y) / 2;\n    do {\n        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\n                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n            inside = !inside;\n        p = p.next;\n    } while (p !== a);\n\n    return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    var a2 = new Node(a.i, a.x, a.y),\n        b2 = new Node(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n\n    a.next = b;\n    b.prev = a;\n\n    a2.next = an;\n    an.prev = a2;\n\n    b2.next = a2;\n    a2.prev = b2;\n\n    bp.next = b2;\n    b2.prev = bp;\n\n    return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    var p = new Node(i, x, y);\n\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\n\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node(i, x, y) {\n    // vertex index in coordinates array\n    this.i = i;\n\n    // vertex coordinates\n    this.x = x;\n    this.y = y;\n\n    // previous and next vertex nodes in a polygon ring\n    this.prev = null;\n    this.next = null;\n\n    // z-order curve value\n    this.z = null;\n\n    // previous and next nodes in z-order\n    this.prevZ = null;\n    this.nextZ = null;\n\n    // indicates whether this is a steiner point\n    this.steiner = false;\n}\n\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nearcut.deviation = function (data, holeIndices, dim, triangles) {\n    var hasHoles = holeIndices && holeIndices.length;\n    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for (var i = 0, len = holeIndices.length; i < len; i++) {\n            var start = holeIndices[i] * dim;\n            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n\n    var trianglesArea = 0;\n    for (i = 0; i < triangles.length; i += 3) {\n        var a = triangles[i] * dim;\n        var b = triangles[i + 1] * dim;\n        var c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs(\n            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\n            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n\n    return polygonArea === 0 && trianglesArea === 0 ? 0 :\n        Math.abs((trianglesArea - polygonArea) / polygonArea);\n};\n\nfunction signedArea(data, start, end, dim) {\n    var sum = 0;\n    for (var i = start, j = end - dim; i < end; i += dim) {\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nearcut.flatten = function (data) {\n    var dim = data[0][0].length,\n        result = {vertices: [], holes: [], dimensions: dim},\n        holeIndex = 0;\n\n    for (var i = 0; i < data.length; i++) {\n        for (var j = 0; j < data[i].length; j++) {\n            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);\n        }\n        if (i > 0) {\n            holeIndex += data[i - 1].length;\n            result.holes.push(holeIndex);\n        }\n    }\n    return result;\n};\n","import earcut from 'earcut';\nimport turf from '@turf/turf';\n\n/**\n * @description Perform constrained triangulation of feature.\n * @param {Polygon} polygon Polygon to triangulate.\n * @private\n * @return {FeatureCollection<Polygon>} Feature collection of triangles.\n */\nconst triangulate = (polygon) => {\n  const data = earcut.flatten(polygon.geometry.coordinates);\n  const triangles = earcut(data.vertices, data.holes, data.dimensions);\n\n  const polygons = [];\n\n  // Unflatten each triangle vertex data from earcut data and triangulation.\n  const numTriangles = triangles.length / 3;\n  for (let i = 0; i < numTriangles; ++i) {\n    // Collect each triangle vertex\n    const vertices = [];\n\n    for (let j = 0; j < 3; ++j) {\n      // Collect each vertex dimension\n      const vertex = [];\n      for (let k = 0; k < data.dimensions; ++k) {\n        const index = data.dimensions * triangles[3 * i + j] + k;\n        vertex.push(data.vertices[index]);\n      }\n      vertices.push(vertex);\n    }\n\n    // Close triangle coordinate array with initial coordinate.\n    vertices.push(vertices[0]);\n\n    polygons.push(turf.polygon([vertices]));\n  }\n\n  return turf.featureCollection(polygons);\n};\n\n/**\n * @description Perform constrained triangulation of polygon(s). Triangulation\n *              is performed on each polygon separately and then combined.\n * @param {Polygons} geojson Features to triangulate.\n * @private\n * @return {FeatureCollection<Polygon>} Feature collection of triangles.\n */\nexport default (geojson) => {\n  const polygons = [];\n  turf.flattenEach(geojson, (feature) => {\n    const triangles = triangulate(feature);\n    turf.featureEach(triangles, (triangle) => {\n      polygons.push(triangle);\n    });\n  });\n  return turf.featureCollection(polygons);\n};\n","import triangulate from './triangulate';\nimport turf from '@turf/turf';\n\n// Scaling factor to apply to features to attempt and recover from a known\n// Turfjs dependency numerical precision bug. The features will be scaled by\n// this scale factor, the clipping applied, then unscaled.\nconst scaleFactor = 1.0;\n\n/**\n * @description Clip subject triangle using a triangle clipper. The result will\n *              be a collection of triangles that partition the subject triangle\n *              and preserve the clipping boundary.\n * @param {Polygon} subject Triangle to be clipped.\n * @param {Polygon} clipper Triangle with which to clip.\n * @private\n * @return {FeatureCollection<Polygon>} Triangle clipped components.\n */\nconst clip = (subject, clipper) => {\n  const triangles = [];\n\n  // Intersect subject with clipper and retriangulate intersection.\n  let intersection = clipIntersection(subject, clipper);\n  if (!intersection && scaleFactor != 1.0) {\n    // Attempt to recover from turf failure by scaling features.\n    intersection = clipScale(subject, clipper, scaleFactor, clipIntersection);\n  }\n  if (intersection) {\n    Array.prototype.push.apply(triangles, intersection);\n  }\n\n  // Difference subject with clipper and retriangulate difference.\n  let difference = clipDifference(subject, clipper);\n  if (!difference && scaleFactor != 1.0) {\n    // Attempt to recover from turf failure by scaling features.\n    difference = clipScale(subject, clipper, scaleFactor, clipDifference);\n  }\n  if (difference) {\n    Array.prototype.push.apply(triangles, difference);\n  }\n\n  // If no triangles were found then assume subject was not clipped.\n  // This should only happen if Turf failed during intersection and\n  // difference due to an on-going numerical precision bug.\n  if (triangles.length == 0) {\n    triangles.push(subject);\n  }\n\n  return turf.featureCollection(triangles);\n};\n\n/**\n * @description Clip subject triangle using a triangle clipper. The result will\n *              be a collection of triangles that are the difference of the\n *              subject triangle and the clipper.\n * @param {Polygon} subject Triangle to be clipped.\n * @param {Polygon} clipper Triangle with which to clip.\n * @private\n * @return {FeatureCollection<Polygon>} Collection of clipped intersections\n *                                      or null if intersection failed.\n */\nconst clipDifference = (subject, clipper) => {\n  const triangles = [];\n\n  // Difference subject with clipper and retriangulate difference.\n  try {\n    const difference = turf.difference(subject, clipper);\n    if (difference === null) {\n      return null;\n    }\n    if (difference && difference.geometry.type.includes('Polygon')) {\n      turf.flattenEach(difference, (flattened) => {\n        turf.featureEach(triangulate(flattened), (feature) => {\n          triangles.push(feature);\n        });\n      });\n    }\n  } catch (e) {\n    // Turf differrence can fail for edge cases due to one of their\n    // dependencies not handling numerical precision well.\n    // It is discussed at length in their issue tracker.\n    // https://github.com/Turfjs/turf/issues\n    return null;\n  }\n\n  return triangles;\n};\n\n/**\n * @description Clip subject triangle using a triangle clipper. The result will\n *              be a collection of triangles that intersect the subject triangle\n *              and the clipper.\n * @param {Polygon} subject Triangle to be clipped.\n * @param {Polygon} clipper Triangle with which to clip.\n * @private\n * @return {FeatureCollection<Polygon>} Collection of clipped intersections\n *                                      or null if intersection failed.\n */\nconst clipIntersection = (subject, clipper) => {\n  const triangles = [];\n\n  // Intersect subject with clipper and retriangulate intersection.\n  try {\n    const intersection = turf.intersect(subject, clipper);\n    if (intersection === null) {\n      return null;\n    }\n    if (intersection && intersection.geometry.type.includes('Polygon')) {\n      turf.flattenEach(intersection, (flattened) => {\n        turf.featureEach(triangulate(flattened), (feature) => {\n          triangles.push(feature);\n        });\n      });\n    }\n  } catch (e) {\n    // Turf intersect can fail for edge cases due to one of their\n    // dependencies not handling numerical precision well.\n    // It is discussed at length in their issue tracker.\n    // https://github.com/Turfjs/turf/issues\n    return null;\n  }\n\n  return triangles;\n};\n\n/**\n * @description Apply operation to scaled subject & clipper then unscale result.\n * @param {Polygon} subject Triangle to be clipped.\n * @param {Polygon} clipper Triangle with which to clip.\n * @param {Number} scale Scaling factor.\n * @param {Function} operation CLipping operation to apply.\n * @private\n * @return {FeatureCollection<Polygon>} Collection of operation results\n *                                      or null if operation failed.\n */\nconst clipScale = (subject, clipper, scale, operation) => {\n  const subjectScaled = turf.clone(subject);\n  const clipperScaled = turf.clone(clipper);\n  coordScale(subjectScaled, scale);\n  coordScale(clipperScaled, scale);\n\n  // Apply clipping operation and unscale results\n  let result = operation(subjectScaled, clipperScaled);\n  if (!result) {\n    return null;\n  }\n  result = turf.featureCollection(result);\n  coordScale(result, 1.0 / scale);\n\n  return result.features;\n};\n\n/**\n * @description Scale each GeoJSON coordinate.\n * @param {GeoJSON} geojson GeoJSON to scale.\n * @param {Number} scale Scaling factor.\n * @private\n */\nconst coordScale = (geojson, scale) => {\n  turf.coordEach(geojson, (coordinate) => {\n    for (let i = 0; i < coordinate.length; ++i) {\n      coordinate[i] *= scale;\n    }\n  });\n};\n\n/**\n * @description Clip subject segment using a collection of segment clippers.\n *              The result will be a collection of segments that partition the\n *              subject segment and preserve the clipping boundaries.\n * @param {LineString} subject Segment to be clipped.\n * @param {FeatureCollection<LineString>} clippers Segments with which to clip.\n * @private\n * @return {LineString} Segment clipped partitioning. Note line may contain\n *                      duplicate points if partitioned but multiple clippers.\n */\nconst segment = (subject, clippers) => {\n  const vertices = subject.geometry.coordinates.concat();\n\n  // Split subject at intersection points and collect coordinates.\n  // Turf only finds interections where the segments are non-parallel.\n  const intersections = turf.lineIntersect(subject, clippers);\n  turf.coordEach(intersections, (coordinate) => {\n    vertices.push(coordinate);\n  });\n\n  // Split subject at overlap points if no intersections found.\n  // If turf found no intersections between two segments then\n  // the only case left is an overlap in which case one or both\n  // end points of the clipper will be on the subject.\n  turf.coordEach(clippers, (coordinate) => {\n    if (turf.booleanPointOnLine(coordinate, subject, {\n      ignoreEndVertices: true,\n    })) {\n      vertices.push(coordinate);\n    }\n  });\n\n  // Sort all coordinates in order from first vertex.\n  if (vertices.length >= 2) {\n    vertices.sort((a, b) => {\n      const start = subject.geometry.coordinates[0];\n      return turf.distance(a, start) - turf.distance(b, start);\n    });\n  }\n\n  return turf.lineString(vertices);\n};\n\n/**\n * @description Clip subject triangle using a collection of triangle clippers.\n *              The result will be a collection of triangles that partition the\n *              subject triangle and preserve the clipping boundaries.\n * @param {Polygon} subject Triangle to be clipped.\n * @param {FeatureCollection<Polygon>} clippers Triangles with which to clip.\n * @private\n * @return {FeatureCollection<Polygon>} Triangle clipped partitioning.\n */\nconst triangle = (subject, clippers) => {\n  let subjects = [subject];\n\n  turf.featureEach(clippers, (clipper, i) => {\n    // Clip all subjects with the current clipper and then put the resulting\n    // triangle partition back in the queue to be clipped by the next clipper.\n    const parts = [];\n    for (let i = 0; i < subjects.length; i++) {\n      const triangles = clip(subjects[i], clipper);\n      turf.featureEach(triangles, (facet) => {\n        parts.push(facet);\n      });\n    }\n    subjects = parts;\n  });\n\n  return turf.featureCollection(subjects);\n};\n\nexport default {\n  segment,\n  triangle,\n};\n","import turf from '@turf/turf';\n\n/**\n * @description Compute centroid of each segment in GeoJSON.\n * @param {GeoJSON} geojson GeoJSON of ilne features to process.\n * @private\n * @return {FeatureCollection<Point>} Collection of segment centroids.\n */\nconst centroids = (geojson) => {\n  // Compute centroid of each feature.\n  const centers = [];\n  turf.segmentEach(geojson, (feature) => {\n    centers.push(turf.centroid(feature));\n  });\n  return turf.featureCollection(centers);\n};\n\n/**\n * @description Test if two GeoJSON bounding boxes are disjoint.\n * @param {GeoJSON} geojson1 GeoJSON #1 to test.\n * @param {GeoJSON} geojson2 GeoJSON #2 to test.\n * @private\n * @return {Boolean} True if bounding boxes are disjoint otherwise false.\n */\nconst disjoint = (geojson1, geojson2) => {\n  const bbox1 = (geojson1.bbox ? geojson1.bbox : turf.bbox(geojson1));\n  const bbox2 = (geojson2.bbox ? geojson2.bbox : turf.bbox(geojson2));\n  if ((bbox1[0] > bbox2[2]) ||\n    (bbox1[2] < bbox2[0]) ||\n    (bbox1[1] > bbox2[3]) ||\n    (bbox1[3] < bbox2[1])) {\n    return true;\n  }\n  return false;\n};\n\n/**\n * @description Test if two arrays are similar. Similarity is equality where\n *              offset and direction are ignored. When array ends are reached\n *              the comparison wraps around to the other end and continues.\n * @param {Array} array1 Array #1.\n * @param {Array} array2 Array #2.\n * @param {Number} [start1=0] Starting index of array #1.\n * @param {Number} [start2=0] Starting index of array #2.\n * @param {Number} [count=-1] Number of elements to check for equality from\n *                            starting index. If -1 then all checked.\n * @param {Boolean} [reverse=false] True if coordinates #2 should be checked\n *                                  in reverse order from #1 otherwise false.\n * @private\n * @return {Boolean} True if are equal otherwise false.\n */\nconst similar = (array1, array2, start1 = 0, start2 = 0, count =-1,\n    reverse = false) => {\n  if (array1.length !== array2.length) {\n    return false;\n  }\n\n  // Determine how many elements to check for equality.\n  const length = array1.length - 1;\n  if (count < 0) {\n    count = length;\n  }\n  count = Math.min(length, Math.max(count, 0));\n\n  for (let i = 0; i < count; i = i + 1) {\n    // Choose direction to traverse array #2\n    const delta = (reverse ? -i : i);\n\n    // Wrapped around starting index of each array\n    const index1 = ((start1 + i) + length) % length;\n    const index2 = ((start2 + delta) + length) % length;\n\n    // Check if all coordinate dimensions are equal.\n    const isEqual = array1[index1].every((dimension, j) => {\n      return dimension === array2[index2][j];\n    });\n    if (isEqual === false) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nexport default {\n  centroids,\n  disjoint,\n  similar,\n};\n","import turf from '@turf/turf';\n\n/**\n * @description Get base geometry type. Defined only for homogenous geometries.\n * @param {GeoJSON} geojson GeoJSON object.\n * @private\n * @return {Point|LineString|Polygon|Mixed|Unknown} Base geometry type.\n */\nconst type = (geojson) => {\n  // Check if we have a single geometry type.\n  const geoType = turf.getType(geojson);\n  const isMany = ['Collection', 'Multi'].some((many) => geoType.includes(many));\n  if (isMany === false) {\n    return geoType;\n  }\n\n  // For a collection or multipart geometry, flatten to find a common type.\n  return turf.flattenReduce(geojson, (baseType, feature, index) => {\n    if (baseType === 'Mixed') {\n      return baseType;\n    }\n    const currentType = turf.getType(feature);\n    if (baseType !== 'Unknown' && baseType !== currentType) {\n      return 'Mixed';\n    }\n    return currentType;\n  }, 'Unknown');\n};\n\nexport default {\n  type,\n};\n","import turf from '@turf/turf';\n\n/**\n * @description Check if callback is true for every coordinate.\n * @param {GeoJSON} geojson Any GeoJSON.\n * @param {function} callback Callback for each coordinate of GeoJSON.\n * @private\n * @return {Boolean} True if every coordinate returns true otherwise false.\n */\nconst coordEvery = (geojson, callback) => {\n  return reduceEvery(geojson, callback, turf.coordReduce);\n};\n\n/**\n * @description Check if callback is true for some coordinate.\n * @param {GeoJSON} geojson Any GeoJSON.\n * @param {function} callback Callback for each coordinate of GeoJSON.\n * @private\n * @return {Boolean} True if some coordinate returns true otherwise false.\n */\nconst coordSome = (geojson, callback) => {\n  return reduceSome(geojson, callback, turf.coordReduce);\n};\n\n/**\n * @description Check if callback is true for every feature.\n * @param {GeoJSON} geojson Any GeoJSON.\n * @param {function} callback Callback for each feature of GeoJSON.\n * @private\n * @return {Boolean} True if every feature returns true otherwise false.\n */\nconst featureEvery = (geojson, callback) => {\n  return reduceEvery(geojson, callback, turf.featureReduce);\n};\n\n/**\n * @description Check if callback is true for some feature.\n * @param {GeoJSON} geojson Any GeoJSON.\n * @param {function} callback Callback for each feature of GeoJSON.\n * @private\n * @return {Boolean} True if some feature returns true otherwise false.\n */\nconst featureSome = (geojson, callback) => {\n  return reduceSome(geojson, callback, turf.featureReduce);\n};\n\n/**\n * @description Check if callback is true for every flattened feature.\n * @param {GeoJSON} geojson Any GeoJSON.\n * @param {function} callback Callback for each feature of GeoJSON.\n * @private\n * @return {Boolean} True if some feature returns true otherwise false.\n */\nconst flattenEvery = (geojson, callback) => {\n  return reduceEvery(geojson, callback, turf.flattenReduce);\n};\n\n/**\n * @description Check if callback is true for some flattened feature.\n * @param {GeoJSON} geojson Any GeoJSON.\n * @param {function} callback Callback for each feature of GeoJSON.\n * @private\n * @return {Boolean} True if some feature returns true otherwise false.\n */\nconst flattenSome = (geojson, callback) => {\n  return reduceSome(geojson, callback, turf.flattenReduce);\n};\n\n/**\n * @description Check if callback is true for every reduce item.\n * @param {GeoJSON} geojson Any GeoJSON.\n * @param {function} callback Callback for each GeoJSON reduction item.\n * @param {function} reducer Turf reduction function.\n * @private\n * @return {Boolean} True if every item returns true otherwise false.\n */\nconst reduceEvery = (geojson, callback, reducer) => {\n  return reducer(geojson, (value, feature) => {\n    return value && callback(feature);\n  }, true);\n};\n\n/**\n * @description Check if callback is true for some reduce item.\n * @param {GeoJSON} geojson Any GeoJSON.\n * @param {function} callback Callback for each GeoJSON reduction item.\n * @param {function} reducer Turf reduction function.\n * @private\n * @return {Boolean} True if some item returns true otherwise false.\n */\nconst reduceSome = (geojson, callback, reducer) => {\n  return reducer(geojson, (value, feature) => {\n    return value || callback(feature);\n  }, false);\n};\n\n/**\n * @description Check if callback is true for every segment.\n * @param {GeoJSON} geojson Any GeoJSON.\n * @param {function} callback Callback for each segment of GeoJSON.\n * @private\n * @return {Boolean} True if every segment returns true otherwise false.\n */\nconst segmentEvery = (geojson, callback) => {\n  return reduceEvery(geojson, callback, turf.segmentReduce);\n};\n\n/**\n * @description Check if callback is true for some segment.\n * @param {GeoJSON} geojson Any GeoJSON.\n * @param {function} callback Callback for each segment of GeoJSON.\n * @private\n * @return {Boolean} True if some segment returns true otherwise false.\n */\nconst segmentSome = (geojson, callback) => {\n  return reduceSome(geojson, callback, turf.segmentReduce);\n};\n\nexport default {\n  coordEvery,\n  coordSome,\n  featureEvery,\n  featureSome,\n  flattenEvery,\n  flattenSome,\n  segmentEvery,\n  segmentSome,\n};\n","function quickselect(arr, k, left, right, compare) {\n    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);\n}\n\nfunction quickselectStep(arr, k, left, right, compare) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselectStep(arr, k, newLeft, newRight, compare);\n        }\n\n        var t = arr[k];\n        var i = left;\n        var j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) i++;\n            while (compare(arr[j], t) > 0) j--;\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nexport default quickselect;\n","import quickselect from './quickselect';\n\nfunction rbush(maxEntries, format) {\n    if (!(this instanceof rbush)) return new rbush(maxEntries, format);\n\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\n    this._maxEntries = Math.max(4, maxEntries || 9);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n\n    if (format) {\n        this._initFormat(format);\n    }\n\n    this.clear();\n}\n\nrbush.prototype = {\n\n    all: function () {\n        return this._all(this.data, []);\n    },\n\n    search: function (bbox) {\n\n        var node = this.data,\n            result = [],\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return result;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    },\n\n    collides: function (bbox) {\n\n        var node = this.data,\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return false;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    },\n\n    load: function (data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (var i = 0, len = data.length; i < len; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                var tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    },\n\n    insert: function (item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    },\n\n    clear: function () {\n        this.data = createNode([]);\n        return this;\n    },\n\n    remove: function (item, equalsFn) {\n        if (!item) return this;\n\n        var node = this.data,\n            bbox = this.toBBox(item),\n            path = [],\n            indexes = [],\n            i, parent, index, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    },\n\n    toBBox: function (item) { return item; },\n\n    compareMinX: compareNodeMinX,\n    compareMinY: compareNodeMinY,\n\n    toJSON: function () { return this.data; },\n\n    fromJSON: function (data) {\n        this.data = data;\n        return this;\n    },\n\n    _all: function (node, result) {\n        var nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push.apply(result, node.children);\n            else nodesToSearch.push.apply(nodesToSearch, node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    },\n\n    _build: function (items, left, right, height) {\n\n        var N = right - left + 1,\n            M = this._maxEntries,\n            node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        var N2 = Math.ceil(N / M),\n            N1 = N2 * Math.ceil(Math.sqrt(M)),\n            i, j, right2, right3;\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (i = left; i <= right; i += N1) {\n\n            right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (j = i; j <= right2; j += N2) {\n\n                right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    },\n\n    _chooseSubtree: function (bbox, node, level, path) {\n\n        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            minArea = minEnlargement = Infinity;\n\n            for (i = 0, len = node.children.length; i < len; i++) {\n                child = node.children[i];\n                area = bboxArea(child);\n                enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    },\n\n    _insert: function (item, level, isNode) {\n\n        var toBBox = this.toBBox,\n            bbox = isNode ? item : toBBox(item),\n            insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    },\n\n    // split overflowed node into two\n    _split: function (insertPath, level) {\n\n        var node = insertPath[level],\n            M = node.children.length,\n            m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        var splitIndex = this._chooseSplitIndex(node, m, M);\n\n        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    },\n\n    _splitRoot: function (node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    },\n\n    _chooseSplitIndex: function (node, m, M) {\n\n        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n\n        minOverlap = minArea = Infinity;\n\n        for (i = m; i <= M - m; i++) {\n            bbox1 = distBBox(node, 0, i, this.toBBox);\n            bbox2 = distBBox(node, i, M, this.toBBox);\n\n            overlap = intersectionArea(bbox1, bbox2);\n            area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index;\n    },\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis: function (node, m, M) {\n\n        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\n            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\n            xMargin = this._allDistMargin(node, m, M, compareMinX),\n            yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    },\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin: function (node, m, M, compare) {\n\n        node.children.sort(compare);\n\n        var toBBox = this.toBBox,\n            leftBBox = distBBox(node, 0, m, toBBox),\n            rightBBox = distBBox(node, M - m, M, toBBox),\n            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\n            i, child;\n\n        for (i = m; i < M - m; i++) {\n            child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (i = M - m - 1; i >= m; i--) {\n            child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    },\n\n    _adjustParentBBoxes: function (bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (var i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    },\n\n    _condense: function (path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (var i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    },\n\n    _initFormat: function (format) {\n        // data format (minX, minY, maxX, maxY accessors)\n\n        // uses eval-type function compilation instead of just accepting a toBBox function\n        // because the algorithms are very sensitive to sorting functions performance,\n        // so they should be dead simple and without inner calls\n\n        var compareArr = ['return a', ' - b', ';'];\n\n        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n\n        this.toBBox = new Function('a',\n            'return {minX: a' + format[0] +\n            ', minY: a' + format[1] +\n            ', maxX: a' + format[2] +\n            ', maxY: a' + format[3] + '};');\n    }\n};\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (var i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (var i = k, child; i < p; i++) {\n        child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    var minX = Math.max(a.minX, b.minX),\n        minY = Math.max(a.minY, b.minY),\n        maxX = Math.min(a.maxX, b.maxX),\n        maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children: children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    var stack = [left, right],\n        mid;\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n\nexport default rbush;\n","import rbush from './rbush';\nimport {featureEach, coordEach} from '@turf/meta';\n\n/**\n * GeoJSON implementation of [RBush](https://github.com/mourner/rbush#rbush) spatial index.\n *\n * @name rbush\n * @param {number} [maxEntries=9] defines the maximum number of entries in a tree node. 9 (used by default) is a\n * reasonable choice for most applications. Higher value means faster insertion and slower search, and vice versa.\n * @returns {RBush} GeoJSON RBush\n * @example\n * import geojsonRbush from 'geojson-rbush';\n * var tree = geojsonRbush();\n */\nfunction geojsonRbush(maxEntries) {\n    var tree = rbush(maxEntries);\n    /**\n     * [insert](https://github.com/mourner/rbush#data-format)\n     *\n     * @param {Feature<any>} feature insert single GeoJSON Feature\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var polygon = {\n     *   \"type\": \"Feature\",\n     *   \"properties\": {},\n     *   \"geometry\": {\n     *     \"type\": \"Polygon\",\n     *     \"coordinates\": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]\n     *   }\n     * }\n     * tree.insert(polygon)\n     */\n    tree.insert = function (feature) {\n        if (Array.isArray(feature)) {\n            var bbox = feature;\n            feature = bboxPolygon(bbox);\n            feature.bbox = bbox;\n        } else {\n            feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n        }\n        return rbush.prototype.insert.call(this, feature);\n    };\n\n    /**\n     * [load](https://github.com/mourner/rbush#bulk-inserting-data)\n     *\n     * @param {BBox[]|FeatureCollection<any>} features load entire GeoJSON FeatureCollection\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var polygons = {\n     *   \"type\": \"FeatureCollection\",\n     *   \"features\": [\n     *     {\n     *       \"type\": \"Feature\",\n     *       \"properties\": {},\n     *       \"geometry\": {\n     *         \"type\": \"Polygon\",\n     *         \"coordinates\": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]\n     *       }\n     *     },\n     *     {\n     *       \"type\": \"Feature\",\n     *       \"properties\": {},\n     *       \"geometry\": {\n     *         \"type\": \"Polygon\",\n     *         \"coordinates\": [[[-93, 32], [-83, 32], [-83, 39], [-93, 39], [-93, 32]]]\n     *       }\n     *     }\n     *   ]\n     * }\n     * tree.load(polygons)\n     */\n    tree.load = function (features) {\n        var load = [];\n        // Load an Array of BBox\n        if (Array.isArray(features)) {\n            features.forEach(function (bbox) {\n                var feature = bboxPolygon(bbox);\n                feature.bbox = bbox;\n                load.push(feature);\n            });\n        } else {\n            // Load FeatureCollection\n            featureEach(features, function (feature) {\n                feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n                load.push(feature);\n            });\n        }\n        return rbush.prototype.load.call(this, load);\n    };\n\n    /**\n     * [remove](https://github.com/mourner/rbush#removing-data)\n     *\n     * @param {BBox|Feature<any>} feature remove single GeoJSON Feature\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var polygon = {\n     *   \"type\": \"Feature\",\n     *   \"properties\": {},\n     *   \"geometry\": {\n     *     \"type\": \"Polygon\",\n     *     \"coordinates\": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]\n     *   }\n     * }\n     * tree.remove(polygon)\n     */\n    tree.remove = function (feature) {\n        if (Array.isArray(feature)) {\n            var bbox = feature;\n            feature = bboxPolygon(bbox);\n            feature.bbox = bbox;\n        }\n        return rbush.prototype.remove.call(this, feature);\n    };\n\n    /**\n     * [clear](https://github.com/mourner/rbush#removing-data)\n     *\n     * @returns {RBush} GeoJSON Rbush\n     * @example\n     * tree.clear()\n     */\n    tree.clear = function () {\n        return rbush.prototype.clear.call(this);\n    };\n\n    /**\n     * [search](https://github.com/mourner/rbush#search)\n     *\n     * @param {BBox|FeatureCollection|Feature<any>} geojson search with GeoJSON\n     * @returns {FeatureCollection<any>} all features that intersects with the given GeoJSON.\n     * @example\n     * var polygon = {\n     *   \"type\": \"Feature\",\n     *   \"properties\": {},\n     *   \"geometry\": {\n     *     \"type\": \"Polygon\",\n     *     \"coordinates\": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]\n     *   }\n     * }\n     * tree.search(polygon)\n     */\n    tree.search = function (geojson) {\n        var features = rbush.prototype.search.call(this, this.toBBox(geojson));\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    };\n\n    /**\n     * [collides](https://github.com/mourner/rbush#collisions)\n     *\n     * @param {BBox|FeatureCollection|Feature<any>} geojson collides with GeoJSON\n     * @returns {boolean} true if there are any items intersecting the given GeoJSON, otherwise false.\n     * @example\n     * var polygon = {\n     *   \"type\": \"Feature\",\n     *   \"properties\": {},\n     *   \"geometry\": {\n     *     \"type\": \"Polygon\",\n     *     \"coordinates\": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]\n     *   }\n     * }\n     * tree.collides(polygon)\n     */\n    tree.collides = function (geojson) {\n        return rbush.prototype.collides.call(this, this.toBBox(geojson));\n    };\n\n    /**\n     * [all](https://github.com/mourner/rbush#search)\n     *\n     * @returns {FeatureCollection<any>} all the features in RBush\n     * @example\n     * tree.all()\n     * //=FeatureCollection\n     */\n    tree.all = function () {\n        var features = rbush.prototype.all.call(this);\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    };\n\n    /**\n     * [toJSON](https://github.com/mourner/rbush#export-and-import)\n     *\n     * @returns {any} export data as JSON object\n     * @example\n     * var exported = tree.toJSON()\n     * //=JSON object\n     */\n    tree.toJSON = function () {\n        return rbush.prototype.toJSON.call(this);\n    };\n\n    /**\n     * [fromJSON](https://github.com/mourner/rbush#export-and-import)\n     *\n     * @param {any} json import previously exported data\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var exported = {\n     *   \"children\": [\n     *     {\n     *       \"type\": \"Feature\",\n     *       \"geometry\": {\n     *         \"type\": \"Point\",\n     *         \"coordinates\": [110, 50]\n     *       },\n     *       \"properties\": {},\n     *       \"bbox\": [110, 50, 110, 50]\n     *     }\n     *   ],\n     *   \"height\": 1,\n     *   \"leaf\": true,\n     *   \"minX\": 110,\n     *   \"minY\": 50,\n     *   \"maxX\": 110,\n     *   \"maxY\": 50\n     * }\n     * tree.fromJSON(exported)\n     */\n    tree.fromJSON = function (json) {\n        return rbush.prototype.fromJSON.call(this, json);\n    };\n\n    /**\n     * Converts GeoJSON to {minX, minY, maxX, maxY} schema\n     *\n     * @private\n     * @param {BBox|FeatureCollectio|Feature<any>} geojson feature(s) to retrieve BBox from\n     * @returns {Object} converted to {minX, minY, maxX, maxY}\n     */\n    tree.toBBox = function (geojson) {\n        var bbox;\n        if (geojson.bbox) bbox = geojson.bbox;\n        else if (Array.isArray(geojson) && geojson.length === 4) bbox = geojson;\n        else bbox = turfBBox(geojson);\n\n        return {\n            minX: bbox[0],\n            minY: bbox[1],\n            maxX: bbox[2],\n            maxY: bbox[3]\n        };\n    };\n    return tree;\n}\n\n/**\n * Takes a bbox and returns an equivalent {@link Polygon|polygon}.\n *\n * @private\n * @name bboxPolygon\n * @param {Array<number>} bbox extent in [minX, minY, maxX, maxY] order\n * @returns {Feature<Polygon>} a Polygon representation of the bounding box\n * @example\n * var bbox = [0, 0, 10, 10];\n *\n * var poly = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [poly]\n */\nfunction bboxPolygon(bbox) {\n    var lowLeft = [bbox[0], bbox[1]];\n    var topLeft = [bbox[0], bbox[3]];\n    var topRight = [bbox[2], bbox[3]];\n    var lowRight = [bbox[2], bbox[1]];\n    var coordinates = [[lowLeft, lowRight, topRight, topLeft, lowLeft]];\n\n    return {\n        type: 'Feature',\n        bbox: bbox,\n        properties: {},\n        geometry: {\n            type: 'Polygon',\n            coordinates: coordinates\n        }\n    };\n}\n\n/**\n * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.\n *\n * @private\n * @name bbox\n * @param {FeatureCollection|Feature<any>} geojson input features\n * @returns {Array<number>} bbox extent in [minX, minY, maxX, maxY] order\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);\n * var bbox = turf.bbox(line);\n * var bboxPolygon = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [line, bboxPolygon]\n */\nfunction turfBBox(geojson) {\n    var bbox = [Infinity, Infinity, -Infinity, -Infinity];\n    coordEach(geojson, function (coord) {\n        if (bbox[0] > coord[0]) bbox[0] = coord[0];\n        if (bbox[1] > coord[1]) bbox[1] = coord[1];\n        if (bbox[2] < coord[0]) bbox[2] = coord[0];\n        if (bbox[3] < coord[1]) bbox[3] = coord[1];\n    });\n    return bbox;\n}\n\nexport default geojsonRbush;\n","import { feature, lineString } from '@turf/helpers';\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    if (geomType === 'MultiPolygon') geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    coordEach(geometry.geometries[j], callback, excludeWrapCoord);\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            callback(geojson.features[i].properties, i);\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            callback(geojson.features[i], i);\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                callback(null, featureIndex, featureProperties, featureBBox, featureId);\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                callback(geometry, featureIndex, featureProperties, featureBBox, featureId);\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId);\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            callback(feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0);\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        geometry.coordinates.forEach(function (coordinate, multiFeatureIndex) {\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            callback(feature(geom, properties), featureIndex, multiFeatureIndex);\n        });\n\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature$$1.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature$$1.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        coordReduce(feature$$1, function (previousCoords, currentCoord, coordIndex, featureIndexCoord, mutliPartIndexCoord, geometryIndex) {\n            var currentSegment = lineString([previousCoords, currentCoord], feature$$1.properties);\n            callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n            segmentIndex++;\n            return currentCoord;\n        });\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n        if (feature$$1.geometry === null) return;\n        var type = feature$$1.geometry.type;\n        var coords = feature$$1.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            callback(feature$$1, featureIndex, multiFeatureIndex, 0, 0);\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                callback(lineString(coords[geometryIndex], feature$$1.properties), featureIndex, multiFeatureIndex, geometryIndex);\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\nexport { coordEach, coordReduce, propEach, propReduce, featureEach, featureReduce, coordAll, geomEach, geomReduce, flattenEach, flattenReduce, segmentEach, segmentReduce, lineEach, lineReduce };\n","import clipper from './clipper';\nimport rbush from 'geojson-rbush';\nimport turf from '@turf/turf';\n\n/**\n * @description Compute partition of line relative to boundaries of polygons.\n * @param {LineString} linestring Line to be partitioned.\n * @param {Polgons} polygons Polygon with which to partition.\n * @private\n * @return {LineString} Partitioned line.\n */\nconst boundaries = (linestring, polygons) => {\n  let linePartition = linestring;\n  turf.flattenEach(polygons, (poly) => {\n    const boundary = turf.polygonToLine(poly);\n    linePartition = line(linePartition, boundary);\n  });\n  return linePartition;\n};\n\n/**\n * @description Compute partition of line #1 relative to line(s) #2.\n *              The partition is itself a line that ensures that\n *              each line segment intersects only one line #2 segment.\n * @param {LineString} line1 Line #1.\n * @param {Lines} lines2 Line #2.\n * @private\n * @return {LineString} Line partition of line #1.\n */\nconst line = (line1, lines2) => {\n  const coordinates = [];\n\n  // Load line #2 segments into R-Tree for quick searching.\n  const segments2 = turf.lineSegment(lines2);\n  const tree = rbush();\n  tree.load(segments2);\n\n  // Clip each line #1 segment with nearby line #2 segments.\n  turf.segmentEach(line1, (segment1) => {\n    const clippers = tree.search(segment1);\n    const vertices = clipper.segment(segment1, clippers);\n    const coords = turf.getCoords(vertices);\n    Array.prototype.push.apply(coordinates, coords);\n  });\n\n  // Remove sequential duplicate coordinates.\n  const lines = coordinates.filter((current, i) => {\n    if (i === 0) {\n      return true;\n    }\n    return current.some((dimension, j) => {\n      return (dimension !== coordinates[i-1][j]);\n    });\n  });\n\n  return turf.lineString(lines);\n};\n\n/**\n * @description Compute partition of polygon #1 relative to polygon #2.\n *              The partition is itself a triangulation that ensures that\n *              each partition triangle is either in polygon #1 or #2.\n * @param {FeatureCollection<Polygon>} triangulation1 Polygon #1 triangulation.\n * @param {FeatureCollection<Polygon>} triangulation2 Polygon #2 triangulation.\n * @private\n * @return {FeatureCollection<Polygon>} Triangle partition of polygon #1.\n */\nconst polygon = (triangulation1, triangulation2) => {\n  const triangles = [];\n\n  // Load triangulation #2 into R-Tree for quick searching.\n  const tree = rbush();\n  tree.load(triangulation2);\n\n  turf.featureEach(triangulation1, (triangle1) => {\n    const clippers = tree.search(triangle1);\n    const clips = clipper.triangle(triangle1, clippers);\n    Array.prototype.push.apply(triangles, clips.features);\n  });\n\n  return turf.featureCollection(triangles);\n};\n\nexport default {\n  boundaries,\n  line,\n  polygon,\n};\n","import helpers from './helpers';\nimport meta from './meta';\nimport turf from '@turf/turf';\n\n/**\n * @description One or more points.\n * @private\n * @typedef {Feature|FeatureCollection<Point|MultiPoint>} Points\n */\n\n/**\n * @description Test if point(s) in GeoJSON is in line.\n * @param {GeoJSON} geojson GeoJSON points to test.\n * @param {Lines} lines Line(s) to contain points.\n * @param {Boolean} [boundary] True if line boundary should be included.\n *                  Default is true.\n * @param {Boolean} [every] True if every point should be in line.\n *                  False if only some points should be in line.\n *                  Default is true.\n * @param {Boolean} [within] True if relationship is \"within\" otherwise\n *                           \"outside\". Default is true.\n * @private\n * @return {Boolean} True if point(s) is in line otherwise false.\n */\nconst isInLine = (geojson, lines, boundary, every, within) => {\n  boundary = boundary !== false;\n  every = every !== false;\n  within = within !== false;\n\n  if (helpers.disjoint(geojson, lines)) {\n    return within === false;\n  }\n\n  const reducerGeo = (every ? meta.coordEvery : meta.coordSome);\n  const reducerLines = (within ? meta.flattenSome : meta.flattenEvery);\n\n  return reducerGeo(geojson, (coordinate) => {\n    return reducerLines(lines, (linestring) => {\n      return turf.booleanPointOnLine(coordinate, linestring, {\n        ignoreEndVertices: boundary === false,\n      }) === within;\n    });\n  });\n};\n\n/**\n * @description Test if every point in GeoJSON is in points.\n * @param {GeoJSON} geojson GeoJSON points to test.\n * @param {Points} points Points(s) to contain points.\n * @param {Boolean} [every] True if every point should be in points.\n *                  False if only some points should be in points.\n *                  Default is true.\n * @param {Boolean} [within] True if relationship is \"within\" otherwise\n *                           \"outside\". Default is true.\n * @private\n * @return {Boolean} True if point(s) is in point otherwise false.\n */\nconst isInPoint = (geojson, points, every, within) => {\n  every = every !== false;\n  within = within !== false;\n\n  if (helpers.disjoint(geojson, points)) {\n    return within === false;\n  }\n\n  const reducerGeo = (every ? meta.coordEvery : meta.coordSome);\n  const reducerPts = (within ? meta.flattenSome : meta.flattenEvery);\n\n  return reducerGeo(geojson, (coordinate) => {\n    const point1 = turf.point(coordinate);\n    return reducerPts(points, (point2) => {\n      return point1.geometry.coordinates.every((dimension, index) => {\n        return dimension === point2.geometry.coordinates[index];\n      }) === within;\n    });\n  });\n};\n\n/**\n * @description Test if point(s) in GeoJSON is in polygon.\n * @param {GeoJSON} geojson GeoJSON points to test.\n * @param {Polygons} polygons Polygon(s) to contain point.\n * @param {Boolean} [boundary] True if polygon boundary should be included.\n *                  Default is true.\n * @param {Boolean} [every] True if every point should be in polygon.\n *                  False if only some points should be in polygon.\n *                  Default is true.\n * @param {Boolean} [within] True if relationship is \"within\" otherwise\n *                           \"outside\". Default is true.\n * @private\n * @return {Boolean} True if point(s) is in polygon otherwise false.\n */\nconst isInPolygon = (geojson, polygons, boundary, every, within) => {\n  boundary = boundary !== false;\n  every = every !== false;\n  within = within !== false;\n\n  if (helpers.disjoint(geojson, polygons)) {\n    return within === false;\n  }\n\n  const reducerGeo = (every ? meta.coordEvery : meta.coordSome);\n  const reducerPoly = (within ? meta.flattenSome : meta.flattenEvery);\n\n  return reducerGeo(geojson, (coordinate) => {\n    return reducerPoly(polygons, (polygon) => {\n      return turf.booleanPointInPolygon(coordinate, polygon, {\n        ignoreBoundary: boundary === false,\n      }) === within;\n    });\n  });\n};\n\nexport default {\n  isInLine,\n  isInPoint,\n  isInPolygon,\n};\n","import helpers from './helpers';\nimport meta from './meta';\nimport partition from './partition';\nimport point from './point';\nimport turf from '@turf/turf';\n\n/**\n * @description One or more lines.\n * @private\n * @typedef {Feature|FeatureCollection<LineString|MultiLineString>} Lines\n */\n\n/**\n * @description Get line ending point.\n * @param {LineString} linestring Line from which to get ending point.\n * @private\n * @return {Point} Ending point.\n */\nconst end = (linestring) => {\n  const length = linestring.geometry.coordinates.length;\n  return turf.point(linestring.geometry.coordinates[length-1]);\n};\n\n/**\n * @description Test if line(s) #1 is disjoint from line(s) #2.\n * @param {Lines} lines1 Line #1 to be tested.\n * @param {Lines} lines2 Line #2 to be tested.\n * @private\n * @return {Boolean} True if they are disjoint otherwise false.\n */\nconst isDisjoint = (lines1, lines2) => {\n  // Check for any proper sement/segment intersections.\n  const intersections = isIntersecting(lines1, lines2, true);\n  if (intersections) {\n    return false;\n  }\n\n  // Check for segment/segment overlaps.\n  const overlaps = isOverlapping(lines1, lines2, true, false, true);\n  if (overlaps) {\n    return false;\n  }\n\n  // Final case is boundaries touching\n  const touches = isTouching(lines1, lines2);\n  if (touches) {\n    return false;\n  }\n\n  return true;\n};\n\n/**\n * @description Test if line(s) #1 and line(s) #2 have any intersections.\n * @param {Lines} lines1 Line #1 to be intersected.\n * @param {Lines} lines2 Line #2 to be intersected.\n * @param {Boolean} [boundary] True if line boundary should be included.\n *                  Default is true.\n * @private\n * @return {Boolean} True if they have intersections otherwise false.\n */\nconst isIntersecting = (lines1, lines2, boundary) => {\n  boundary = boundary !== false;\n\n  // Check for any proper sement/segment intersections.\n  // Turf only finds interections where the segments are non-parallel.\n  return meta.flattenSome(lines1, (line1) => {\n    return meta.flattenSome(lines2, (line2) => {\n      const intersects = turf.lineIntersect(line1, line2);\n      if (boundary === false) {\n        const lines = turf.featureCollection([line1, line2]);\n        if (isOnBoundary(lines, intersects)) {\n          return false;\n        }\n      }\n      return intersects.features.length > 0;\n    });\n  });\n};\n\n/**\n * @description Test if point(s) is on line(s) boundary.\n * @param {Lines} lines Line to be tested.\n * @param {Points} points Points to be tested.\n * @private\n * @return {Boolean} True if on boundary otherwise false.\n */\nconst isOnBoundary = (lines, points) => {\n  return meta.featureEvery(points, (pt) => {\n    // Flatten lines and check if point is on any boundary.\n    return meta.flattenSome(lines, (linestring) => {\n      const lineStart = start(linestring);\n      const lineEnd = end(linestring);\n      if (point.isInPoint(pt, lineStart) ||\n          point.isInPoint(pt, lineEnd)) {\n        return true;\n      }\n    });\n  });\n};\n\n/**\n * @description Test if line(s) #1 and line(s) #2 have overlaps.\n * @param {Lines} lines1 Line #1 to be tested.\n * @param {Lines} lines2 Line #2 to be tested.\n * @param {Boolean} [boundary] True if line boundary should be included.\n *                  Default is true.\n * @param {Boolean} [every] True if every segment should overlap line.\n *                  False if only some segments should overlap line.\n *                  Default is true.\n * @param {Boolean} [within] True if relationship is \"within\" otherwise\n *                           \"outside\". Default is true.\n * @param {Number} [tolerance] Tolerance distance to match overlapping line\n *                             segments (kilometers). Default is 0.\n * @private\n * @return {Boolean} True if they have overlaps otherwise false.\n */\nconst isOverlapping = (lines1, lines2, boundary, every, within, tolerance) => {\n  boundary = boundary !== false;\n  every = every !== false;\n  tolerance = tolerance || 0;\n  within = within !== false;\n\n  const reducer = (every ? meta.segmentEvery : meta.segmentSome);\n  return reducer(lines1, (line1) => {\n    // Partition line #1 using line #2 as clipper.\n    const partition1 = partition.line(line1, lines2);\n    return reducer(partition1, (segment) => {\n      // Check for segment/segment overlaps by testing centroid.\n      const centroid = turf.centroid(segment);\n      let inLine = point.isInLine(centroid, lines2, boundary);\n      if (inLine === false && tolerance > 0) {\n        const nearest = turf.nearestPointOnLine(lines2, centroid);\n        inLine = nearest.properties.dist <= tolerance;\n      }\n      return inLine === within;\n    });\n  });\n};\n\n/**\n * @description Test if two line coordinates are similar. Similarity is\n *              vertex equality with array shift and direction ignored.\n * @example\n *  similar(turf.lineString([[0, 0], [1, 1], [2, 3], [3, 4]]),\n *          turf.lineString([[1, 1], [0, 0], [3, 4], [2, 3]])); // = true\n * @param {Lines} lines1 Line #1.\n * @param {Lines} lines2 Line #2.\n * @private\n * @return {Boolean} True if similar otherwise false.\n */\nconst isSimilar = (lines1, lines2) => {\n  // Flatten all lines then search for matches.\n  const findMatch = (features1, features2) => {\n    return meta.flattenEvery(features1, (line1) => {\n      return meta.flattenSome(features2, (line2) => {\n        const coords1 = line1.geometry.coordinates;\n        const coords2 = line2.geometry.coordinates;\n        const length2 = coords2.length-1;\n        return (helpers.similar(coords1, coords2) ||\n          helpers.similar(coords1, coords2, 0, length2-1, length2, true));\n      });\n    });\n  };\n\n  return findMatch(lines1, lines2) && findMatch(lines2, lines1);\n};\n\n/**\n * @description Test if any line(s) #1 boundary touches line(s) #2 boundary.\n * @param {Lines} lines1 Line #1 to be tested.\n * @param {Lines} lines2 Line #2 to be tested.\n * @private\n * @return {Boolean} True if their boundaries touch otherwise false.\n */\nconst isTouching = (lines1, lines2) => {\n  // Flatten both lines and check if end points are equal.\n  return meta.flattenSome(lines1, (line1) => {\n    const start1 = start(line1);\n    const end1 = end(line1);\n\n    return meta.flattenSome(lines2, (line2) => {\n      const start2 = start(line2);\n      if (point.isInPoint(start1, start2) ||\n          point.isInPoint(end1, start2)) {\n        return true;\n      }\n\n      const end2 = end(line2);\n      if (point.isInPoint(start1, end2) ||\n          point.isInPoint(end1, end2)) {\n        return true;\n      }\n    });\n  });\n};\n\n/**\n * @description Get line starting point.\n * @param {LineString} linestring Line from which to get starting point.\n * @private\n * @return {Point} Starting point.\n */\nconst start = (linestring) => {\n  return turf.point(linestring.geometry.coordinates[0]);\n};\n\nexport default {\n  end,\n  isDisjoint,\n  isIntersecting,\n  isOverlapping,\n  isSimilar,\n  isTouching,\n  start,\n};\n","import helpers from './helpers';\nimport line from './line';\nimport meta from './meta';\nimport partition from './partition';\nimport point from './point';\nimport triangulate from './triangulate';\nimport turf from '@turf/turf';\n\n/**\n * @description One or more polygons.\n * @private\n * @typedef {Feature|FeatureCollection<Polygon|MultiPolygon>} Polygons\n */\n\n/**\n * @description Test if polygon boundaries intersect.\n * @param {Polygons} polygons1 Polygons #1.\n * @param {Polygons} polygons2 Polygons #2.\n * @private\n * @return {Boolean} True if boundary's intersect otherwise false.\n */\nconst isBoundaryIntersecting = (polygons1, polygons2) => {\n  // Flatten both polygons then intersect their boundaries.\n  return meta.flattenSome(polygons1, (polygon1) => {\n    const boundary1 = turf.polygonToLine(polygon1);\n    return meta.flattenSome(polygons2, (polygon2) => {\n      const boundary2 = turf.polygonToLine(polygon2);\n      return line.isDisjoint(boundary1, boundary2) === false;\n    });\n  });\n};\n\n/**\n * @description Test if two coordinate arrays are similar. Similarity is\n *              equality where shift and direction changes are ignored.\n *              Arrays must be of same length.\n * @param {Array} coordinates1 Coordinates #1 array.\n * @param {Array} coordinates2 Coordinates #2 array.\n * @private\n * @return {Boolean} True if coordinates are similar otherwise false.\n */\nconst isCoordinateSimilar = (coordinates1, coordinates2) => {\n  // First find a pair of coordinates that are equal then check rest of array\n  const length = coordinates1.length - 1;\n  for (let i = 0; i < length; ++i) {\n    // Search for similarity in forward direction\n    if (helpers.similar(coordinates1, coordinates2, 0, i, 1, true)) {\n      if (helpers.similar(coordinates1, coordinates2, 0, i, length, true)) {\n        return true;\n      }\n    }\n\n    // Search for similarity in reverse direction\n    if (helpers.similar(coordinates1, coordinates2, 0, i, 1, false)) {\n      if (helpers.similar(coordinates1, coordinates2, 0, i, length, false)) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/**\n * @description Test if polygon(s) #1 is within polygon(s) #2.\n * @param {Polygons} polygons1 Polygon #1.\n * @param {Polygons} polygons2 Polygon #2.\n * @private\n * @return {Boolean} True if within otherwise false.\n */\nconst isInPolygon = (polygons1, polygons2) => {\n  // Check that all vertices in #1 are in the interior of #2\n  if (point.isInPolygon(polygons1, polygons2, true, true) === false) {\n    return false;\n  }\n\n  // Check the centroid of each partition triangle is within polygon #2.\n  return relate(polygons1, polygons2, false, true, true);\n};\n\n/**\n * @description Test if two polygon coordinates are similar. Similarity is\n *              vertex equality with array shift and direction ignored.\n * @example\n *  similar(turf.polygon([[[0, 0], [1, 1], [2, 3], [3, 4]]]),\n *          turf.polygon([[[1, 1], [0, 0], [3, 4], [2, 3]]])); // = true\n * @param {Polygons} polygons1 Polygon #1.\n * @param {Polygons} polygons2 Polygon #2.\n * @private\n * @return {Boolean} True if similar otherwise false.\n */\nconst isPolygonSimilar = (polygons1, polygons2) => {\n  // Flatten all polygon rings into lines then search for matches.\n  const findMatch = (features1, features2) => {\n    return meta.flattenEvery(features1, (feature1) => {\n      return feature1.geometry.coordinates.every((line1) => {\n        return meta.flattenSome(features2, (feature2) => {\n          return feature2.geometry.coordinates.some((line2) => {\n            return isCoordinateSimilar(line1, line2);\n          });\n        });\n      });\n    });\n  };\n\n  return findMatch(polygons1, polygons2) && findMatch(polygons2, polygons1);\n};\n\n/**\n * @description Relate polygon(s) #1 to polygon(s) #2.\n * @param {Polygons} polygons1 Polygon #1 to relate.\n * @param {Polygons} polygons2 Polygon #2 to relate.\n * @param {Boolean} [boundary] True if boundary should be included.\n *                  Default is true.\n * @param {Boolean} [every] True if every polygon(s) #1 meets relationship.\n *                  False if only some of polygon(s) #1 meets relationship.\n *                  Default is true.\n * @param {Boolean} [within] True if relationship is \"within\" otherwise\n *                           \"outside\". Default is true.\n * @private\n * @return {Boolean} True if relationship met otherwise false.\n */\nconst relate = (polygons1, polygons2, boundary, every, within) => {\n  boundary = boundary !== false;\n  every = every !== false;\n  within = within !== false;\n\n  // Rule out case where polygon coordinates are identical which can cause\n  // trouble for the clipping tools used during partitioning if the\n  // triangulations are identical and vertices are high precision.\n  if (isPolygonSimilar(polygons1, polygons2)) {\n    return within === true;\n  }\n\n  // Compute the partition of polygon #1 relative to #2 so that each partition\n  // triangle is either entirely within or outside polygon #2. Then, we have\n  // to check if the centroid of each partition triangle satisfies relation.\n  const triangulation1 = triangulate(polygons1);\n  const triangulation2 = triangulate(polygons2);\n  const partition1 = partition.polygon(triangulation1, triangulation2);\n\n  const reducer = (every ? meta.featureEvery : meta.featureSome);\n  return reducer(partition1, (triangle) => {\n    const centroid = turf.centroid(triangle);\n    return point.isInPolygon(centroid, polygons2, boundary) === within;\n  });\n};\n\nexport default {\n  isBoundaryIntersecting,\n  isInPolygon,\n  relate,\n};\n","import clipper from './clipper';\nimport helpers from './helpers';\nimport invariant from './invariant';\nimport line from './line';\nimport meta from './meta';\nimport partition from './partition';\nimport point from './point';\nimport polygon from './polygon';\nimport triangulate from './triangulate';\n\nexport default {\n  clipper,\n  helpers,\n  invariant,\n  line,\n  meta,\n  partition,\n  point,\n  polygon,\n  triangulate,\n};\n","import util from '../util';\n\n/**\n * @description Test if line(s) #1 is within line(s) #2.\n * @param {Lines} lines1 Line #1.\n * @param {Lines} lines2 Line #2.\n * @private\n * @return {Boolean} True if within otherwise false.\n */\nconst withinLine = (lines1, lines2) => {\n  if (util.helpers.disjoint(lines1, lines2)) {\n    return false;\n  }\n\n  // Rule out case where line coordinates are identical which can cause\n  // trouble for the clipping tools used during partitioning if the\n  // line strings are identical and vertices are high precision.\n  if (util.line.isSimilar(lines1, lines2)) {\n    return true;\n  }\n\n  // Check that all vertex in #1 are in the interior of #2\n  if (util.point.isInLine(lines1, lines2, true, true) === false) {\n    return false;\n  }\n\n  // Check if the centroid of each partition segment is within lines #2.\n  const overlaps = util.line.isOverlapping(lines1, lines2, false, true, true);\n  if (overlaps) {\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * @description Test if line(s) is within polygon(s).\n * @param {Lines} lines Line to be tested.\n * @param {Polgons} polygons Polygon to be tested.\n * @private\n * @return {Boolean} True if within otherwise false.\n */\nconst withinPolygon = (lines, polygons) => {\n  if (util.helpers.disjoint(lines, polygons)) {\n    return false;\n  }\n\n  // Partition each line using polygon boundaries so that each partition\n  // segment is either within or outside the polygons.\n  return util.meta.flattenEvery(lines, (linestring) => {\n    // Check that no centroid is in the exterior of all polygons\n    const linePartition = util.partition.boundaries(linestring, polygons);\n    const centroids = util.helpers.centroids(linePartition);\n    const notExterior = util.point.isInPolygon(centroids, polygons, true, true);\n    if (notExterior === false) {\n      return false;\n    }\n\n    // Check that atleast one point is in the interior.\n    return util.point.isInPolygon(centroids, polygons, false, false);\n  });\n};\n\nexport default {\n  withinLine,\n  withinPolygon,\n};\n","import util from '../util';\n\n/**\n * @description Test if point(s) are within line(s).\n * @param {Points} points Point to test.\n * @param {Lines} lines Lines to test.\n * @private\n * @return {Boolean} True if within otherwise false.\n */\nconst withinLine = (points, lines) => {\n  if (util.helpers.disjoint(points, lines)) {\n    return false;\n  }\n\n  // Check that no point is in the exterior of all polygons\n  // and there is at least one interior point.\n  const notExterior = util.point.isInLine(points, lines, true, true);\n  if (notExterior === false) {\n    return false;\n  }\n\n  // Check that atleast one point is in the interior.\n  return util.point.isInLine(points, lines, false, false);\n};\n\n/**\n * @description Test if point(s) #1 are within point(s) #2.\n * @param {Points} points1 Point #1 to test.\n * @param {Points} points2 Point #2 to test.\n * @private\n * @return {Boolean} True if within otherwise false.\n */\nconst withinPoint = (points1, points2) => {\n  if (util.helpers.disjoint(points1, points2)) {\n    return false;\n  }\n\n  // Test that every point in #1 equals some in #2.\n  return util.point.isInPoint(points1, points2, true);\n};\n\n/**\n * @description Test if point(s) are within polygon(s).\n * @param {Points} points Point to test.\n * @param {Polygons} polygons Polygons to test.\n * @private\n * @return {Boolean} True if within otherwise false.\n */\nconst withinPolygon = (points, polygons) => {\n  if (util.helpers.disjoint(points, polygons)) {\n    return false;\n  }\n\n  // Check that no point is in the exterior of all polygons\n  // and there is at least one interior point.\n  const notExterior = util.point.isInPolygon(points, polygons, true, true);\n  if (notExterior === false) {\n    return false;\n  }\n\n  // Check that atleast one point is in the interior.\n  return util.point.isInPolygon(points, polygons, false, false);\n};\n\nexport default {\n  withinLine,\n  withinPoint,\n  withinPolygon,\n};\n","import util from '../util';\n\n/**\n * @description Test if polygon(s) #1 is within polygon(s) #2.\n * @param {Polygons} polygons1 Polygon #1.\n * @param {Polygons} polygons2 Polygon #2.\n * @private\n * @return {Boolean} True if within otherwise false.\n */\nconst withinPolygon = (polygons1, polygons2) => {\n  if (util.helpers.disjoint(polygons1, polygons2)) {\n    return false;\n  }\n\n  // Check the polygon #1 is within polygon #2.\n  return util.polygon.isInPolygon(polygons1, polygons2);\n};\n\nexport default {\n  withinPolygon,\n};\n","import line from './line';\nimport point from './point';\nimport polygon from './polygon';\nimport util from '../util';\n\n/**\n * @description Check if geojson #1 is within geojson #2.\n * @param {GeoJSON} geojson1 GeoJSON #1.\n * @param {GeoJSON} geojson2 GeoJSON #2.\n * @param {Boolean} [error=true] If true unsupported geometries throw an\n *                               error, otherwise they return false.\n * @return {Boolean} True if within otherwise false.\n */\nconst within = (geojson1, geojson2, error=true) => {\n  const type1 = util.invariant.type(geojson1);\n  const type2 = util.invariant.type(geojson2);\n  const type = `${type1}-${type2}`;\n  switch (type) {\n    case 'LineString-LineString':\n      return line.withinLine(geojson1, geojson2);\n    case 'LineString-Polygon':\n      return line.withinPolygon(geojson1, geojson2);\n    case 'Point-LineString':\n      return point.withinLine(geojson1, geojson2);\n    case 'Point-Point':\n      return point.withinPoint(geojson1, geojson2);\n    case 'Point-Polygon':\n      return point.withinPolygon(geojson1, geojson2);\n    case 'Polygon-Polygon':\n      return polygon.withinPolygon(geojson1, geojson2);\n    default:\n      if (error) {\n        throw new Error(`${type1} within ${type2} not supported.`);\n      }\n      return false;\n  }\n};\n\nexport default within;\n","import util from '../util';\nimport within from '../within';\n\n/**\n * @description Check if geojson #1 contains geojson #2.\n * @param {GeoJSON} geojson1 GeoJSON #1.\n * @param {GeoJSON} geojson2 GeoJSON #2.\n * @param {Boolean} [error=true] If true unsupported geometries throw an\n *                               error, otherwise they return false.\n * @return {Boolean} True if contained otherwise false.\n */\nconst contains = (geojson1, geojson2, error=true) => {\n  const type1 = util.invariant.type(geojson1);\n  const type2 = util.invariant.type(geojson2);\n  const type = `${type1}-${type2}`;\n  switch (type) {\n    case 'LineString-LineString':\n    case 'LineString-Point':\n    case 'Point-Point':\n    case 'Polygon-LineString':\n    case 'Polygon-Point':\n    case 'Polygon-Polygon':\n      return within(geojson2, geojson1);\n    default:\n      if (error) {\n        throw new Error(`${type1} contains ${type2} not supported.`);\n      }\n      return false;\n  }\n};\n\nexport default contains;\n","import line from '../within/line';\nimport util from '../util';\n\n/**\n * @description Test if line(s) #1 covered by line(s) #2.\n * @param {Lines} lines1 Line #1 to be tested.\n * @param {Lines} lines2 Line #2 to be tested.\n * @private\n * @return {Boolean} True if line is covered by otherwise false.\n */\nconst coveredbyLine = (lines1, lines2) => {\n  return line.withinLine(lines1, lines2);\n};\n\n/**\n * @description Test if line(s) coveredby polygon(s).\n * @param {Lines} lines Lines to test.\n * @param {Polygons} polygons Polygon to test.\n * @private\n * @return {Boolean} True if covers otherwise false.\n */\nconst coveredbyPolygon = (lines, polygons) => {\n  if (util.helpers.disjoint(lines, polygons)) {\n    return false;\n  }\n\n  // Test that all line segments are within or on the boundary of the polygons.\n  return util.meta.flattenEvery(lines, (linestring) => {\n    // Partition each line with polygon boundaries and test partition centroids.\n    const linePartition = util.partition.boundaries(linestring, polygons);\n    const centroids = util.helpers.centroids(linePartition);\n    return util.point.isInPolygon(centroids, polygons, true, true, true);\n  });\n};\n\nexport default {\n  coveredbyLine,\n  coveredbyPolygon,\n};\n","import util from '../util';\n\n/**\n * @description Test if point(s) coveredby line(s).\n * @param {Points} points Point to test.\n * @param {Lines} lines Line to test.\n * @private\n * @return {Boolean} True if coveredby otherwise false.\n */\nconst coveredbyLine = (points, lines) => {\n  if (util.helpers.disjoint(points, lines)) {\n    return false;\n  }\n\n  // Test that all points are within or on the boundary of the polygons.\n  return util.point.isInLine(points, lines, true, true, true);\n};\n\n/**\n * @description Test if point(s) #1 coveredby point(s) #2.\n * @param {Points} points1 Point #1 to test.\n * @param {Points} points2 Point #2 to test.\n * @private\n * @return {Boolean} True if coveredby otherwise false.\n */\nconst coveredbyPoint = (points1, points2) => {\n  if (util.helpers.disjoint(points1, points2)) {\n    return false;\n  }\n\n  // Test that every point in #1 covers points in #2.\n  return util.point.isInPoint(points1, points2, true);\n};\n\n/**\n * @description Test if point(s) coveredby polygon(s).\n * @param {Points} points Point to test.\n * @param {Polygons} polygons Polygon to test.\n * @private\n * @return {Boolean} True if coveredby otherwise false.\n */\nconst coveredbyPolygon = (points, polygons) => {\n  if (util.helpers.disjoint(points, polygons)) {\n    return false;\n  }\n\n  // Test that all points are within or on the boundary of the polygons.\n  return util.point.isInPolygon(points, polygons, true, true, true);\n};\n\nexport default {\n  coveredbyLine,\n  coveredbyPoint,\n  coveredbyPolygon,\n};\n","import util from '../util';\n\n/**\n * @description Test if polygon(s) #1 is coveredby polygon(s) #2.\n * @param {Polygons} polygons1 Polygon #1.\n * @param {Polygons} polygons2 Polygon #2.\n * @private\n * @return {Boolean} True if covered otherwise false.\n */\nconst coveredbyPolygon = (polygons1, polygons2) => {\n  if (util.helpers.disjoint(polygons1, polygons2)) {\n    return false;\n  }\n\n  // Check the polygon #1 is within polygon #2.\n  return util.polygon.isInPolygon(polygons1, polygons2);\n};\n\nexport default {\n  coveredbyPolygon,\n};\n","import line from './line';\nimport point from './point';\nimport polygon from './polygon';\nimport util from '../util';\n\n/**\n * @description Check if geojson #1 is coveredby geojson #2.\n * @param {GeoJSON} geojson1 GeoJSON #1.\n * @param {GeoJSON} geojson2 GeoJSON #2.\n * @param {Boolean} [error=true] If true unsupported geometries throw an\n *                               error, otherwise they return false.\n * @return {Boolean} True if coveredby otherwise false.\n */\nconst coveredby = (geojson1, geojson2, error=true) => {\n  const type1 = util.invariant.type(geojson1);\n  const type2 = util.invariant.type(geojson2);\n  const type = `${type1}-${type2}`;\n  switch (type) {\n    case 'LineString-LineString':\n      return line.coveredbyLine(geojson1, geojson2);\n    case 'LineString-Polygon':\n      return line.coveredbyPolygon(geojson1, geojson2);\n    case 'Point-LineString':\n      return point.coveredbyLine(geojson1, geojson2);\n    case 'Point-Point':\n      return point.coveredbyPoint(geojson1, geojson2);\n    case 'Point-Polygon':\n      return point.coveredbyPolygon(geojson1, geojson2);\n    case 'Polygon-Polygon':\n      return polygon.coveredbyPolygon(geojson1, geojson2);\n    default:\n      if (error) {\n        throw new Error(`${type1} coveredby ${type2} not supported.`);\n      }\n      return false;\n  }\n};\n\nexport default coveredby;\n","import util from '../util';\n\n/**\n * @description Test if point(s) crosses line(s).\n * @param {Points} points Points to test.\n * @param {Lines} lines Line to test.\n * @private\n * @return {Boolean} True if crosses otherwise false.\n */\nconst crossesLine = (points, lines) => {\n  if (util.helpers.disjoint(points, lines)) {\n    return false;\n  }\n\n  const within = util.point.isInLine(points, lines, false, false, true);\n  if (within === false) {\n    return false;\n  }\n\n  return util.point.isInLine(points, lines, true, false, false);\n};\n\n/**\n * @description Test if point(s) crosses polygon(s).\n * @param {Points} points Points to test.\n * @param {Polygons} polygons Polygon to test.\n * @private\n * @return {Boolean} True if crosses otherwise false.\n */\nconst crossesPolygon = (points, polygons) => {\n  if (util.helpers.disjoint(points, polygons)) {\n    return false;\n  }\n\n  const within = util.point.isInPolygon(points, polygons, false, false, true);\n  if (within === false) {\n    return false;\n  }\n\n  return util.point.isInPolygon(points, polygons, true, false, false);\n};\n\nexport default {\n  crossesLine,\n  crossesPolygon,\n};\n","import point from './point';\nimport turf from '@turf/turf';\nimport util from '../util';\n\n/**\n * @description Test if line(s) #1 crosses line(s) #2.\n * @param {Lines} lines1 Line #1.\n * @param {Lines} lines2 Line #2.\n * @private\n * @return {Boolean} True if they cross otherwise false.\n */\nconst crossesLine = (lines1, lines2) => {\n  if (util.helpers.disjoint(lines1, lines2)) {\n    return false;\n  }\n\n  // Check if some segment of line #1 is within line #2.\n  const overlaps = util.line.isOverlapping(lines1, lines2, false, false, true);\n  if (overlaps) {\n    return false;\n  }\n\n  // Check for any non-boundary intersections.\n  const intersections = util.line.isIntersecting(lines1, lines2, false);\n  if (intersections) {\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * @description Test if line(s) crosses point(s).\n * @param {Lines} lines Line to test.\n * @param {Points} points Points to test.\n * @private\n * @return {Boolean} True if crosses otherwise false.\n */\nconst crossesPoint = (lines, points) => {\n  return point.crossesLine(points, lines);\n};\n\n/**\n * @description Test if line(s) crosses polygon(s).\n * @param {Lines} lines Lines to test.\n * @param {Polygons} polygons Polygon to test.\n * @private\n * @return {Boolean} True if crosses otherwise false.\n */\nconst crossesPolygon = (lines, polygons) => {\n  if (util.helpers.disjoint(lines, polygons)) {\n    return false;\n  }\n\n  // Search for at least one point in the line that is interior to the polygon\n  // and one point that is in the line that is exterior to polygon.\n  const crosses = turf.flattenReduce(lines, (cross1, linestring) => {\n    if (cross1.within && cross1.outside) {\n      return cross1;\n    }\n\n    // Partition each line with polygon boundaries and test partition centroids.\n    const linePartition = util.partition.boundaries(linestring, polygons);\n    const centroids = util.helpers.centroids(linePartition);\n\n    if (cross1.within === false) {\n      cross1.within = util.point.isInPolygon(\n          centroids, polygons, false, false, true);\n    }\n    if (cross1.outside === false) {\n      cross1.outside = util.point.isInPolygon(\n          centroids, polygons, true, false, false);\n    }\n\n    return cross1;\n  }, {\n    within: false,\n    outside: false,\n  });\n\n  return crosses.within && crosses.outside;\n};\n\nexport default {\n  crossesLine,\n  crossesPoint,\n  crossesPolygon,\n};\n","import line from './line';\nimport point from './point';\n\n/**\n * @description Test if polygon(s) crosses line(s).\n * @param {Polygons} polygons Polygon to test.\n * @param {Lines} lines Lines to test.\n * @private\n * @return {Boolean} True if crosses otherwise false.\n */\nconst crossesLine = (polygons, lines) => {\n  return line.crossesPolygon(lines, polygons);\n};\n\n/**\n * @description Test if polygon(s) crosses point(s).\n * @param {Polygons} polygons Polygon to test.\n * @param {Points} points Points to test.\n * @private\n * @return {Boolean} True if crosses otherwise false.\n */\nconst crossesPoint = (polygons, points) => {\n  return point.crossesPolygon(points, polygons);\n};\n\nexport default {\n  crossesLine,\n  crossesPoint,\n};\n","import util from '../util';\n\n/**\n * @description Test if point(s) intersects line(s).\n * @param {Points} points Point to be intersected.\n * @param {Lines} lines Line to be intersected.\n * @private\n * @return {Boolean} True if they intersect otherwise false.\n */\nconst intersectsLine = (points, lines) => {\n  if (util.helpers.disjoint(points, lines)) {\n    return false;\n  }\n\n  // Test that any point is in some line.\n  return util.point.isInLine(points, lines, true, false);\n};\n\n/**\n * @description Test if point(s) intersect point(s).\n * @param {Points} points1 Point #1 to test.\n * @param {Points} points2 Point #2 to test.\n * @private\n * @return {Boolean} True if they intersect otherwise false.\n */\nconst intersectsPoint = (points1, points2) => {\n  if (util.helpers.disjoint(points1, points2)) {\n    return false;\n  }\n\n  // Check if some point #1 equals point #2.\n  return util.point.isInPoint(points1, points2, false);\n};\n\n/**\n * @description Test if point(s) intersects polygon(s).\n * @param {Points} points Points to be tested.\n * @param {Polygons} polygons Polygons to be tested.\n * @private\n * @return {Boolean} True if intersecting otherwise false.\n */\nconst intersectsPolygon = (points, polygons) => {\n  if (util.helpers.disjoint(points, polygons)) {\n    return false;\n  }\n\n  // Search for at least one point in lines that is in a polygon.\n  return util.point.isInPolygon(points, polygons, true, false);\n};\n\nexport default {\n  intersectsLine,\n  intersectsPoint,\n  intersectsPolygon,\n};\n","import point from './point';\nimport turf from '@turf/turf';\nimport util from '../util';\n\n/**\n * @description Test if line(s) #1 intersects line(s) #2.\n * @param {Lines} lines1 Line #1 to be intersected.\n * @param {Lines} lines2 Line #2 to be intersected.\n * @private\n * @return {Boolean} True if they intersect otherwise false.\n */\nconst intersectsLine = (lines1, lines2) => {\n  if (util.helpers.disjoint(lines1, lines2)) {\n    return false;\n  }\n\n  return util.line.isDisjoint(lines1, lines2) === false;\n};\n\n/**\n * @description Test if line(s) intersects line(s).\n * @param {Lines} lines Line to be intersected.\n * @param {Points} points Point to be intersected.\n * @private\n * @return {Boolean} True if they intersect otherwise false.\n */\nconst intersectsPoint = (lines, points) => {\n  return point.intersectsLine(points, lines);\n};\n\n/**\n * @description Test if line(s) intersects polygon(s).\n * @param {Lines} lines Line to be tested.\n * @param {Polygons} polygons Polygons to be tested.\n * @private\n * @return {Boolean} True if intersecting otherwise false.\n */\nconst intersectsPolygon = (lines, polygons) => {\n  if (util.helpers.disjoint(lines, polygons)) {\n    return false;\n  }\n\n  // Test if polygon boundaries intersect lines.\n  const intersections = util.meta.flattenSome(polygons, (poly) => {\n    const boundary = turf.polygonToLine(poly);\n    return intersectsLine(boundary, lines);\n  });\n  if (intersections) {\n    return true;\n  }\n\n  // Search for at least one point in lines that is interior to a polygon.\n  return util.point.isInPolygon(lines, polygons, true, false);\n};\n\nexport default {\n  intersectsLine,\n  intersectsPoint,\n  intersectsPolygon,\n};\n","import line from './line';\nimport point from './point';\nimport util from '../util';\n\n/**\n * @description Test if polygon(s) intersects line(s).\n * @param {Polygons} polygons Polygons to be tested.\n * @param {Lines} lines Line to be tested.\n * @private\n * @return {Boolean} True if intersecting otherwise false.\n */\nconst intersectsLine = (polygons, lines) => {\n  return line.intersectsPolygon(lines, polygons);\n};\n\n/**\n * @description Test if polygon(s) intersects point(s).\n * @param {Polygons} polygons Polygons to be tested.\n * @param {Points} points Points to be tested.\n * @private\n * @return {Boolean} True if intersecting otherwise false.\n */\nconst intersectsPoint = (polygons, points) => {\n  return point.intersectsPolygon(points, polygons);\n};\n\n/**\n * @description Test if polygon(s) #1 intersects polygon(s) #2.\n * @param {Polygons} polygons1 Polygons #1.\n * @param {Polygons} polygons2 Polygons #2.\n * @private\n * @return {Boolean} True if intersecting otherwise false.\n */\nconst intersectsPolygon = (polygons1, polygons2) => {\n  if (util.helpers.disjoint(polygons1, polygons2)) {\n    return false;\n  }\n\n  // Test if polygon boundaries intersect.\n  const intersections = util.polygon.isBoundaryIntersecting(\n      polygons1, polygons2);\n  if (intersections) {\n    return true;\n  }\n\n  // Search for at least one point in polygon #1 that is interior to polygon #2.\n  return util.polygon.relate(polygons1, polygons2, true, false, true);\n};\n\nexport default {\n  intersectsLine,\n  intersectsPoint,\n  intersectsPolygon,\n};\n","import line from './line';\nimport point from './point';\nimport polygon from './polygon';\nimport util from '../util';\n\n/**\n * @description Check if geojson #1 intersects geojson #2.\n * @param {GeoJSON} geojson1 GeoJSON #1.\n * @param {GeoJSON} geojson2 GeoJSON #2.\n * @param {Boolean} [error=true] If true unsupported geometries throw an\n *                               error, otherwise they return false.\n * @return {Boolean} True if intersects otherwise false.\n */\nconst intersects = (geojson1, geojson2, error=true) => {\n  const type1 = util.invariant.type(geojson1);\n  const type2 = util.invariant.type(geojson2);\n  const type = `${type1}-${type2}`;\n  switch (type) {\n    case 'LineString-LineString':\n      return line.intersectsLine(geojson1, geojson2);\n    case 'LineString-Point':\n      return line.intersectsPoint(geojson1, geojson2);\n    case 'LineString-Polygon':\n      return line.intersectsPolygon(geojson1, geojson2);\n    case 'Point-LineString':\n      return point.intersectsLine(geojson1, geojson2);\n    case 'Point-Point':\n      return point.intersectsPoint(geojson1, geojson2);\n    case 'Point-Polygon':\n      return point.intersectsPolygon(geojson1, geojson2);\n    case 'Polygon-LineString':\n      return polygon.intersectsLine(geojson1, geojson2);\n    case 'Polygon-Point':\n      return polygon.intersectsPoint(geojson1, geojson2);\n    case 'Polygon-Polygon':\n      return polygon.intersectsPolygon(geojson1, geojson2);\n    default:\n      if (error) {\n        throw new Error(`${type1} intersects ${type2} not supported.`);\n      }\n      return false;\n  }\n};\n\nexport default intersects;\n","import util from '../util';\n\n/**\n * @description Test if line(s) #1 overlaps line(s) #2.\n * @param {Lines} lines1 Line #1 to be tested.\n * @param {Lines} lines2 Line #2 to be tested.\n * @private\n * @return {Boolean} True if they overlap otherwise false.\n */\nconst overlapsLine = (lines1, lines2) => {\n  if (util.helpers.disjoint(lines1, lines2)) {\n    return false;\n  }\n\n  // Rule out case where line coordinates are identical which can cause\n  // trouble for the clipping tools used during partitioning if the\n  // line strings are identical and vertices are high precision.\n  if (util.line.isSimilar(lines1, lines2)) {\n    return false;\n  }\n\n  // Check there is line #1 segment interior to line #2\n  const interior = util.line.isOverlapping(\n      lines1, lines2, false, false, true, 0.02);\n  if (interior === false) {\n    return false;\n  }\n\n  // Check there is line #1 segment exterior to line #2\n  const exterior = util.line.isOverlapping(\n      lines1, lines2, true, false, false, 0.02);\n  if (exterior === false) {\n    return false;\n  }\n\n  // Check there is line #2 segment exterior to line #1\n  return util.line.isOverlapping(lines2, lines1, true, false, false, 0.02);\n};\n\nexport default {\n  overlapsLine,\n};\n","import util from '../util';\n\n/**\n * @description Test if point(s) #1 overlaps point(s) #2.\n * @param {Points} points1 Point #1 to be tested.\n * @param {Points} points2 Point #2 to be tested.\n * @private\n * @return {Boolean} True if they overlap otherwise false.\n */\nconst overlapsPoint = (points1, points2) => {\n  if (util.helpers.disjoint(points1, points2)) {\n    return false;\n  }\n\n  // Find point #1 in points #2\n  const oneInTwo = util.point.isInPoint(points1, points2, false, true);\n  if (oneInTwo === false) {\n    return false;\n  }\n\n  // Find point #1 not in points #2\n  const oneNotInTwo = util.point.isInPoint(points1, points2, false, false);\n  if (oneNotInTwo === false) {\n    return false;\n  }\n\n  // Find point #2 not in points #1\n  return util.point.isInPoint(points2, points1, false, false);\n};\n\nexport default {\n  overlapsPoint,\n};\n","import turf from '@turf/turf';\nimport util from '../util';\n\n/**\n * @description Test if polygon(s) #1 overlaps polygon(s) #2.\n * @param {Polygons} polygons1 Polygon #1.\n * @param {Polygons} polygons2 Polygon #2.\n * @private\n * @return {Boolean} True if overlapping otherwise false.\n */\nconst overlapsPolygon = (polygons1, polygons2) => {\n  if (util.helpers.disjoint(polygons1, polygons2)) {\n    return false;\n  }\n\n  // Compute the partition of polygon #1 relative to #2 so that each partition.\n  // triangle is either entirely within or outside polygon #2.\n  const triangulation1 = util.triangulate(polygons1);\n  const triangulation2 = util.triangulate(polygons2);\n  const partition1 = util.partition.polygon(triangulation1, triangulation2);\n\n  // Search for at least one point in polygon #1 that is interior to polygon #2\n  // and one point that is in polygon #1 that is exterior to polygon #2.\n  const overlap1 = turf.featureReduce(partition1, (overlap, triangle) => {\n    if (overlap.within && overlap.outside) {\n      return overlap;\n    }\n\n    const centroid = turf.centroid(triangle);\n    if (util.point.isInPolygon(centroid, polygons2, false)) {\n      overlap.within = true;\n    } else if (util.point.isInPolygon(centroid, polygons2, true) == false) {\n      overlap.outside = true;\n    }\n\n    return overlap;\n  }, {\n    within: false,\n    outside: false,\n  });\n\n  // Stop if not found. No need to check polygon #2\n  if ((overlap1.within && overlap1.outside) === false) {\n    return false;\n  }\n\n  // Search for at least one point in polygon #2 that is exterior to polygon #1.\n  const partition2 = util.partition.polygon(triangulation2, triangulation1);\n  return util.meta.featureSome(partition2, (triangle) => {\n    const centroid = turf.centroid(triangle);\n    return util.point.isInPolygon(centroid, polygons1, true) === false;\n  });\n};\n\nexport default {\n  overlapsPolygon,\n};\n","import util from '../util';\n\n/**\n * @description Test if point(s) touches line(s).\n * @param {Points} points Points to be tested.\n * @param {Lines} lines Lines to be tested.\n * @private\n * @return {Boolean} True if touching otherwise false.\n */\nconst touchesLine = (points, lines) => {\n  if (util.helpers.disjoint(points, lines)) {\n    return false;\n  }\n\n  // Check that no point in #1 is in the interior of #2\n  if (util.point.isInLine(points, lines, false, false, true)) {\n    return false;\n  }\n\n  // Check that some point in #1 is on the boundary of #2\n  return util.point.isInLine(points, lines, true, false, true);\n};\n\n/**\n * @description Test if point(s) touches polygon(s).\n * @param {Points} points Points to be tested.\n * @param {Polygons} polygons Polygons to be tested.\n * @private\n * @return {Boolean} True if touching otherwise false.\n */\nconst touchesPolygon = (points, polygons) => {\n  if (util.helpers.disjoint(points, polygons)) {\n    return false;\n  }\n\n  // Check that no point in #1 is in the interior of #2\n  if (util.point.isInPolygon(points, polygons, false, false, true)) {\n    return false;\n  }\n\n  // Check that some point in #1 is on the boundary of #2\n  return util.point.isInPolygon(points, polygons, true, false, true);\n};\n\nexport default {\n  touchesLine,\n  touchesPolygon,\n};\n","import point from './point';\nimport turf from '@turf/turf';\nimport util from '../util';\n\n/**\n * @description Test if line(s) #1 touches line(s) #2.\n * @param {Lines} lines1 Line #1 to be tested.\n * @param {Lines} lines2 Line #2 to be tested.\n * @private\n * @return {Boolean} True if they touch otherwise false.\n */\nconst touchesLine = (lines1, lines2) => {\n  if (util.helpers.disjoint(lines1, lines2)) {\n    return false;\n  }\n\n  const intersections = util.line.isIntersecting(lines1, lines2, false);\n  if (intersections) {\n    return false;\n  }\n\n  const overlaps = util.line.isOverlapping(lines1, lines2, true, false, true);\n  if (overlaps) {\n    return false;\n  }\n\n  const touches = util.line.isTouching(lines1, lines2);\n  if (touches) {\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * @description Test if line(s) touches point(s).\n * @param {Lines} lines Lines to test.\n * @param {Points} points Points to test.\n * @private\n * @return {Boolean} True if touching otherwise false.\n */\nconst touchesPoint = (lines, points) => {\n  return point.touchesLine(points, lines);\n};\n\n/**\n * @description Test if lines(s) touches polygon(s).\n * @param {Lines} lines Lines to test.\n * @param {Polygons} polygons Polygons to test.\n * @private\n * @return {Boolean} True if touching otherwise false.\n */\nconst touchesPolygon = (lines, polygons) => {\n  if (util.helpers.disjoint(lines, polygons)) {\n    return false;\n  }\n  const touches = turf.flattenReduce(lines, (touches1, linestring) => {\n    // Exit if we've already found an interior point.\n    if (touches1.within) {\n      return touches1;\n    }\n\n    // Check if any line segment is within polygon.\n    const linePartition = util.partition.boundaries(linestring, polygons);\n    const centroids = util.helpers.centroids(linePartition);\n    if (util.point.isInPolygon(centroids, polygons, false, false, true)) {\n      touches1.within = true;\n      return touches1;\n    }\n\n    // Check if there are any line points exterior to polygon\n    if (touches1.exterior === false) {\n      if (util.point.isInPolygon(centroids, polygons, true, false, false)) {\n        touches1.exterior = true;\n      }\n    }\n\n    // Exit if we've already found a boundary point.\n    if (touches1.boundary) {\n      return touches1;\n    }\n\n    // Check if any line segment overlaps polygon boundary.\n    if (util.point.isInPolygon(centroids, polygons, true, false, true)) {\n      touches1.boundary = true;\n      return touches1;\n    }\n\n    // Check either end point falls on some flattened polygon boundary.\n    const endPoints = [util.line.start(linestring), util.line.end(linestring)];\n    const touchesEnd = endPoints.some((pt) => {\n      return util.meta.flattenSome(polygons, (poly) => {\n        const boundaries = turf.polygonToLine(poly);\n        // Boundaries may be MultiLineString so we flatten again.\n        return util.meta.flattenSome(boundaries, (boundary) => {\n          return turf.booleanPointOnLine(pt, boundary, {\n            ignoreEndVertices: false,\n          });\n        });\n      });\n    });\n    if (touchesEnd) {\n      touches1.boundary = true;\n    }\n\n    return touches1;\n  }, {\n    boundary: false,\n    exterior: false,\n    within: false,\n  });\n\n  return touches.within === false && touches.boundary && touches.exterior;\n};\n\nexport default {\n  touchesLine,\n  touchesPoint,\n  touchesPolygon,\n};\n","import line from './line';\nimport point from './point';\nimport util from '../util';\n\n/**\n * @description Test if polygon(s) touches lines(s).\n * @param {Polygons} polygons Polygons to test.\n * @param {Lines} lines Lines to test.\n * @private\n * @return {Boolean} True if touching otherwise false.\n */\nconst touchesLine = (polygons, lines) => {\n  return line.touchesPolygon(lines, polygons);\n};\n\n/**\n * @description Test if polygon(s) touches point(s).\n * @param {Polygons} polygons Polygons to test.\n * @param {Points} points Points to test.\n * @private\n * @return {Boolean} True if touching otherwise false.\n */\nconst touchesPoint = (polygons, points) => {\n  return point.touchesPolygon(points, polygons);\n};\n\n/**\n * @description Test if polygon(s) #1 touches polygon(s) #2.\n * @param {Polygons} polygons1 Polygons #1.\n * @param {Polygons} polygons2 Polygons #2.\n * @private\n * @return {Boolean} True if touching otherwise false.\n */\nconst touchesPolygon = (polygons1, polygons2) => {\n  if (util.helpers.disjoint(polygons1, polygons2)) {\n    return false;\n  }\n\n  // Check that no vertex in #1 is in the interior of #2\n  if (util.point.isInPolygon(polygons1, polygons2, false, false)) {\n    return false;\n  }\n\n  // Check that no vertex in #2 is in the interior of #1\n  if (util.point.isInPolygon(polygons2, polygons1, false, false)) {\n    return false;\n  }\n\n  // Test if polygon boundaries intersect.\n  const intersections = util.polygon.isBoundaryIntersecting(\n      polygons1, polygons2);\n  if (intersections === false) {\n    return false;\n  }\n\n  // Check that no interior point of polygon #1 is interior to polygon #2.\n  return util.polygon.relate(polygons1, polygons2, true, true, false);\n};\n\nexport default {\n  touchesLine,\n  touchesPoint,\n  touchesPolygon,\n};\n","import line from './line';\nimport point from './point';\nimport polygon from './polygon';\nimport util from '../util';\n\n/**\n * @description Check if geojson #1 touches geojson #2.\n * @param {GeoJSON} geojson1 GeoJSON #1.\n * @param {GeoJSON} geojson2 GeoJSON #2.\n * @param {Boolean} [error=true] If true unsupported geometries throw an\n *                               error, otherwise they return false.\n * @return {Boolean} True if touches otherwise false.\n */\nconst touches = (geojson1, geojson2, error=true) => {\n  const type1 = util.invariant.type(geojson1);\n  const type2 = util.invariant.type(geojson2);\n  const type = `${type1}-${type2}`;\n  switch (type) {\n    case 'LineString-LineString':\n      return line.touchesLine(geojson1, geojson2);\n    case 'LineString-Point':\n      return line.touchesPoint(geojson1, geojson2);\n    case 'LineString-Polygon':\n      return line.touchesPolygon(geojson1, geojson2);\n    case 'Point-LineString':\n      return point.touchesLine(geojson1, geojson2);\n    case 'Point-Polygon':\n      return point.touchesPolygon(geojson1, geojson2);\n    case 'Polygon-LineString':\n      return polygon.touchesLine(geojson1, geojson2);\n    case 'Polygon-Point':\n      return polygon.touchesPoint(geojson1, geojson2);\n    case 'Polygon-Polygon':\n      return polygon.touchesPolygon(geojson1, geojson2);\n    default:\n      if (error) {\n        throw new Error(`${type1} touches ${type2} not supported.`);\n      }\n      return false;\n  }\n};\n\nexport default touches;\n","import coveredby from '../coveredby';\nimport util from '../util';\n\n/**\n * @description Check if geojson #1 covers geojson #2.\n * @param {GeoJSON} geojson1 GeoJSON #1.\n * @param {GeoJSON} geojson2 GeoJSON #2.\n * @param {Boolean} [error=true] If true unsupported geometries throw an\n *                               error, otherwise they return false.\n * @return {Boolean} True if covers otherwise false.\n */\nconst covers = (geojson1, geojson2, error=true) => {\n  const type1 = util.invariant.type(geojson1);\n  const type2 = util.invariant.type(geojson2);\n  const type = `${type1}-${type2}`;\n  switch (type) {\n    case 'LineString-LineString':\n    case 'LineString-Point':\n    case 'Point-Point':\n    case 'Polygon-Point':\n    case 'Polygon-LineString':\n    case 'Polygon-Polygon':\n      return coveredby(geojson2, geojson1);\n    default:\n      if (error) {\n        throw new Error(`${type1} covers ${type2} not supported.`);\n      }\n      return false;\n  }\n};\n\nexport default covers;\n","import line from './line';\nimport point from './point';\nimport polygon from './polygon';\nimport util from '../util';\n\n/**\n * @description Check if geojson #1 crosses geojson #2.\n * @param {GeoJSON} geojson1 GeoJSON #1.\n * @param {GeoJSON} geojson2 GeoJSON #2.\n * @param {Boolean} [error=true] If true unsupported geometries throw an\n *                               error, otherwise they return false.\n * @return {Boolean} True if crosses otherwise false.\n */\nconst crosses = (geojson1, geojson2, error=true) => {\n  const type1 = util.invariant.type(geojson1);\n  const type2 = util.invariant.type(geojson2);\n  const type = `${type1}-${type2}`;\n  switch (type) {\n    case 'LineString-LineString':\n      return line.crossesLine(geojson1, geojson2);\n    case 'LineString-Point':\n      return line.crossesPoint(geojson1, geojson2);\n    case 'LineString-Polygon':\n      return line.crossesPolygon(geojson1, geojson2);\n    case 'Point-LineString':\n      return point.crossesLine(geojson1, geojson2);\n    case 'Point-Polygon':\n      return point.crossesPolygon(geojson1, geojson2);\n    case 'Polygon-LineString':\n      return polygon.crossesLine(geojson1, geojson2);\n    case 'Polygon-Point':\n      return polygon.crossesPoint(geojson1, geojson2);\n    default:\n      if (error) {\n        throw new Error(`${type1} crosses ${type2} not supported.`);\n      }\n      return false;\n  }\n};\n\nexport default crosses;\n","import intersects from '../intersects';\nimport util from '../util';\n\n/**\n * @description Check if geojson #1 is disjoint geojson #2.\n * @param {GeoJSON} geojson1 GeoJSON #1.\n * @param {GeoJSON} geojson2 GeoJSON #2.\n * @param {Boolean} [error=true] If true unsupported geometries throw an\n *                               error, otherwise they return false.\n * @return {Boolean} True if disjoint otherwise false.\n */\nconst disjoint = (geojson1, geojson2, error=true) => {\n  const type1 = util.invariant.type(geojson1);\n  const type2 = util.invariant.type(geojson2);\n  const type = `${type1}-${type2}`;\n  switch (type) {\n    case 'LineString-LineString':\n    case 'LineString-Point':\n    case 'LineString-Polygon':\n    case 'Point-LineString':\n    case 'Point-Point':\n    case 'Point-Polygon':\n    case 'Polygon-LineString':\n    case 'Polygon-Point':\n    case 'Polygon-Polygon':\n      return intersects(geojson1, geojson2) === false;\n    default:\n      if (error) {\n        throw new Error(`${type1} disjoint ${type2} not supported.`);\n      }\n      return false;\n  }\n};\n\nexport default disjoint;\n","import contains from '../contains';\nimport util from '../util';\nimport within from '../within';\n\n/**\n * @description Check if geojson #1 equals geojson #2.\n * @param {GeoJSON} geojson1 GeoJSON #1.\n * @param {GeoJSON} geojson2 GeoJSON #2.\n * @param {Boolean} [error=true] If true unsupported geometries throw an\n *                               error, otherwise they return false.\n * @return {Boolean} True if equals otherwise false.\n */\nconst equals = (geojson1, geojson2, error=true) => {\n  const type1 = util.invariant.type(geojson1);\n  const type2 = util.invariant.type(geojson2);\n  const type = `${type1}-${type2}`;\n  switch (type) {\n    case 'LineString-LineString':\n    case 'Point-Point':\n    case 'Polygon-Polygon':\n      return within(geojson1, geojson2) && contains(geojson1, geojson2);\n    default:\n      if (error) {\n        throw new Error(`${type1} equals ${type2} not supported.`);\n      }\n      return false;\n  }\n};\n\nexport default equals;\n","import line from './line';\nimport point from './point';\nimport polygon from './polygon';\nimport util from '../util';\n\n/**\n * @description Check if geojson #1 overlaps geojson #2.\n * @param {GeoJSON} geojson1 GeoJSON #1.\n * @param {GeoJSON} geojson2 GeoJSON #2.\n * @param {Boolean} [error=true] If true unsupported geometries throw an\n *                               error, otherwise they return false.\n * @return {Boolean} True if overlaps otherwise false.\n */\nconst overlaps = (geojson1, geojson2, error=true) => {\n  const type1 = util.invariant.type(geojson1);\n  const type2 = util.invariant.type(geojson2);\n  const type = `${type1}-${type2}`;\n  switch (type) {\n    case 'LineString-LineString':\n      return line.overlapsLine(geojson1, geojson2);\n    case 'Point-Point':\n      return point.overlapsPoint(geojson1, geojson2);\n    case 'Polygon-Polygon':\n      return polygon.overlapsPolygon(geojson1, geojson2);\n    default:\n      if (error) {\n        throw new Error(`${type1} overlaps ${type2} not supported.`);\n      }\n      return false;\n  }\n};\n\nexport default overlaps;\n"],"names":["earcut","data","holeIndices","dim","minX","minY","maxX","maxY","x","y","invSize","hasHoles","length","outerLen","outerNode","linkedList","triangles","next","prev","i","len","start","end","list","queue","steiner","push","getLeftmost","sort","compareX","eliminateHole","filterPoints","eliminateHoles","Math","max","earcutLinked","clockwise","last","signedArea","insertNode","equals","removeNode","again","p","area","ear","pass","z","zOrder","prevZ","nextZ","q","e","tail","numMerges","pSize","qSize","inSize","sortLinked","indexCurve","stop","isEarHashed","isEar","cureLocalIntersections","splitEarcut","a","b","c","pointInTriangle","minTX","minTY","maxTX","maxTY","minZ","maxZ","n","intersects","locallyInside","isValidDiagonal","splitPolygon","hole","m","hx","hy","qx","Infinity","tan","mx","my","tanMin","abs","findHoleBridge","leftmost","ax","ay","bx","by","cx","cy","px","py","intersectsPolygon","inside","middleInside","r","p1","p2","q1","q2","a2","Node","b2","an","bp","this","sum","j","deviation","polygonArea","trianglesArea","flatten","result","vertices","holes","dimensions","holeIndex","d","geojson","polygons","turf","flattenEach","feature","polygon","geometry","coordinates","numTriangles","vertex","k","index","featureCollection","triangulate","featureEach","triangle","clip","subject","clipper","intersection","clipIntersection","Array","prototype","apply","difference","clipDifference","type","includes","flattened","intersect","segment","clippers","concat","intersections","lineIntersect","coordEach","coordinate","booleanPointOnLine","ignoreEndVertices","distance","lineString","subjects","parts","facet","centroids","centers","segmentEach","centroid","disjoint","geojson1","geojson2","bbox1","bbox","bbox2","similar","array1","array2","start1","start2","count","reverse","min","index2","every","dimension","geoType","getType","some","many","flattenReduce","baseType","currentType","reduceEvery","callback","reducer","value","reduceSome","coordEvery","coordReduce","coordSome","featureEvery","featureReduce","featureSome","flattenEvery","flattenSome","segmentEvery","segmentReduce","segmentSome","quickselect","arr","left","right","compare","quickselectStep","log","s","exp","sd","sqrt","newLeft","floor","newRight","t","swap","defaultCompare","tmp","rbush","maxEntries","format","_maxEntries","_minEntries","ceil","_initFormat","clear","findItem","item","items","equalsFn","indexOf","calcBBox","node","toBBox","distBBox","children","destNode","createNode","child","extend","leaf","compareNodeMinX","compareNodeMinY","bboxArea","bboxMargin","contains","height","multiSelect","mid","stack","pop","geojsonRbush","tree","insert","isArray","bboxPolygon","turfBBox","call","load","features","forEach","remove","search","collides","all","toJSON","fromJSON","json","lowLeft","topLeft","topRight","properties","excludeWrapCoord","l","stopG","coords","geometryMaybeCollection","isGeometryCollection","wrapShrink","coordIndex","isFeatureCollection","isFeature","featureIndex","geometries","geomIndex","multiFeatureIndex","geometryIndex","geomType","Error","coord","_all","childBBox","nodesToSearch","_build","slice","_splitRoot","tmpNode","_insert","parent","goingUp","path","indexes","splice","_condense","compareMinX","compareMinY","N","M","pow","right2","right3","N2","N1","_chooseSubtree","level","targetNode","enlargement","minArea","minEnlargement","isNode","insertPath","_split","_adjustParentBBoxes","_chooseSplitAxis","splitIndex","_chooseSplitIndex","newNode","overlap","minOverlap","_allDistMargin","leftBBox","rightBBox","margin","siblings","compareArr","Function","join","line","line1","lines2","segments2","lineSegment","segment1","getCoords","lines","filter","current","boundaries","linestring","linePartition","poly","boundary","polygonToLine","triangulation1","triangulation2","triangle1","clips","isInLine","within","helpers","reducerLines","meta","isInPoint","points","reducerPts","point1","point","point2","isInPolygon","reducerPoly","booleanPointInPolygon","ignoreBoundary","isIntersecting","lines1","line2","isOnBoundary","pt","lineStart","lineEnd","isOverlapping","tolerance","partition1","partition","inLine","nearestPointOnLine","dist","isTouching","end1","end2","isDisjoint","isSimilar","findMatch","features1","features2","coords1","coords2","length2","isPolygonSimilar","polygons1","polygons2","feature1","feature2","coordinates1","coordinates2","isCoordinateSimilar","relate","isBoundaryIntersecting","polygon1","boundary1","polygon2","boundary2","invariant","util","points1","points2","error","type1","type2","coveredby","crosses","cross1","outside","intersectsLine","overlap1","partition2","touches","touches1","exterior","exports"],"mappings":"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"}